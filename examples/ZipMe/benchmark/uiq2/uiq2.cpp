/*  uiq.cpp v2 - universal compression test set generator.
    (C) 2008, Matt Mahoney.

    LICENSE

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 3 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details at
    Visit <http://www.gnu.org/copyleft/gpl.html>.

The purpose of this program is:

1. to generate generic tests for "universal" data compression programs,
2. to make possible public verification of tests on secret data,
3. and to securely generate cryptographically random tests.

The program outputs a sequence of byte strings generated by one million
random Turing machines, each producing 1 to 32 bytes of output. The
data is designed so that "generic" compressors will do well on it,
while compressors tuned to benchmarks or to specialized file types like
text or images will not do as well. The output strings range from very
easy to compress (e.g. a string of all 0 bits) to very hard (a string
of random bits). The strings have a universal or Solomonoff [1]
distribution. They are concatenated together without delimiters.

The output data depends on a seed which can either be specified by
the user or generated randomly so that the output is different each
time the program is run. Randomly generated seeds has at least 128
bits of entropy. The random seed generation feature only works on x86
processors. Other implementations can use external sources of randomness,
such as random.org or throwing dice.

The data is designed so that outputs generated by different seeds
will compress to about 0.1% of each other. The error can be reduced
further, to about 0.02%, by taking the ratio between compressors
of similar capability. The error can also be reduced by averaging
over multiple tests or generating larger output files. The default
file size is about 16.5 MB. Thus, it is possible to rank compressors
and verify benchmark results without developers having access to the
test data and without having to add the size of the decompression
program. Only this program needs to be published. For benchmarks with
public data, only the seed needs to be published.

The pseudo random number generator is cryptographically secure. Thus,
it is not possible to guess the seed or any output data given any other
output data. Each output string is computationally independent of the
others.

UIQ is used as follows: uiq outputfile [seed [size]]

- Outputfile is the name of the output file to be created. It will
  not overwrite an existing file.

- seed is an arbitrary string used to initialize the pseudo random number
  generator. The output depends on the seed. If the seed is omitted,
  then the program generates a random seed of 28 uppercase letters,
  prints it, and uses it to initialize the random number sequence.
  The output data can be reproduced by running the program again with
  the given seed. On non x86 processors, the random number generation
  feature does not work and a seed is required.

- size is the number of random strings to generate. Each string
  is 0 to 32 non-0 bytes followed by a 0 byte. The average
  string length is about 6.5 bytes.

Each output string is generated by a random Turing machine. See
comments for the turing() function for the machine description.

The random number generator is RC4 (http://en.wikipedia.org/wiki/RC4)
with the first 10000 bytes discarded. RC4 is initialized with a key
consisting of the seed including the NUL terminating byte.

Each machine consumes 128 bytes of the RC4 keystream to generate a
128 instruction random program.

On x86 processors, UIQ will generate random seeds using random variations
in CPU instruction timing as measured by sampling the CPU clock using the
RDTSC instruction. When used in a loop, the CPU clock occasionally gives
unpredictable values because of events generated by other processes.
This happens a few hundred or a few thousand times per second. UIQ uses
the following algorithm to generate a 256 byte random string, x:

  x[0..255] = 0
  while randomness tests have not passed
    i = 0  // counter
    repeat 20 million times
      r1 = r2  // previous and current CPU clock
      r2 = rdtsc()  // read CPU clock
      rotate byte x[i] left by 1 bit
      x[i mod 256] XORed with bits 0..7 of r1 XOR bits 8..15 of r2
      i = i + 1

There are 3 tests to pass. UIQ computes delta = r2 - r1 mod 64K, the
16 low bits of the time between loops, which occasionally gives
unpredictably large values. The first test is that at least 2K of the 64K
possible deltas must be observed at least once. Let t1 and t2 be the
low 11 bits of the last two values of i when a new delta is observed:

  if (delta is observed for the first time) then
    t1 = t2
    t2 = i mod 2K

(After 2K, each byte has been rotated 8 times).
The second and third tests that must be passed are for 1.5K of the
2K possible values of t2 to be observed at least once, and for 1.5K
of the possible 2K possible values of t2 - t1 (mod 2K) to be
observed at least once. It may take several seconds up to a minute
for the tests to pass.

This program was compiled with MinGW g++ 3.4.5 and UPX 3.00w as follows:

  g++ -Wall uiq.cpp -O2 -march=pentiumpro -fomit-frame-pointer -s -o uiq.exe
  upx uiq.exe

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <assert.h>

// Read CPU clock. Requires x86 CPU. Tested in 32 and 64 bit modes.
typedef unsigned int(*FP)(void);
FP rdtsc=(FP)(void*)"\x0F\x31\xC3";  // rdtsc, ret

// Return a hardware generated random 256 byte string.
// Tested in 32 bit Windows Me, XP, 2000, and Vista, on single and dual
// core processors, and Linux 2.6.9/x86-64.
const char* random256() {
  fprintf(stderr, "Creating random seed...\n");

  // Check for x86 and RDTSC instruction.
  if (sizeof(int)!=4)
    fprintf(stderr,"Error: 32 bit int required\n"), exit(1);
  int i=0x12345678;
  if (*(char*)&i!=0x78)  // not little endian?
    fprintf(stderr,"Error: x86 processor required\n"), exit(1);
  if (rdtsc()==rdtsc())  // should differ by a few clocks
    fprintf(stderr,"Error: RDTSC failed\n"), exit(1);

  // Generate random data until all 3 randomness tests pass.
  // May take 10 to 90 seconds. Using nice (in Linux) makes it faster.
  static char result[256]={0};  // Output random string
  int r1=0, r2=0;  // Last 2 values returned by rdtsc()
  int count[0x10000]={0};  // r2-r1 mod 64K -> count
  int dcount[0x800]={0}; // i -> count of unique r2-r1 values at time i mod 2K
  int tcount[0x800]={0}; // i -> count of intervals between unique values
  int count2=0, dcount2=0, tcount2=0;  // num. values > 0 in c/d/tcount[]
  clock_t start=clock(); // start time
  while (count2<2048 || dcount2<1536 || tcount2<1536) {
    int t=0;  // last count update
    for (int i=0; i<20000000; ++i) {
      unsigned char x=result[i&255];
      r1=r2;
      r2=rdtsc();
      x=x<<1|x>>7;
      if (++count[r2-r1&0xffff]==1) {
        ++count2;
        if (++dcount[i&0x7ff]==1)
          ++dcount2;
        if (++tcount[t-i&0x7ff]==1)
          ++tcount2;
        t=i;
      }
      x^=r1;
      x^=r2>>8;
      result[i&255]=x;
    }
    fprintf(stderr,
      "%d/2048 deltas, %d/1536 locations, %d/1536 intervals in %1.3f s\r",
      count2, dcount2, tcount2, double(clock()-start)/CLOCKS_PER_SEC);
  }
  fprintf(stderr, "\n");
  return result;
}

// RC4-drop[10000] keystream generator.
// See http://en.wikipedia.org/wiki/RC4
class RC4 {
public:
  void init(const char *key, int len);  // key schedule
  int get();  // get 1 byte of pseudo random stream
private:
  unsigned char s[256];
  int i, j;
  void swap(unsigned char& a, unsigned char& b) {
    unsigned char t=a; a=b; b=t;
  }
} rc4;

// Key schedule
void RC4::init(const char *key, int len) {
  j=0;
  for (i=0; i<256; ++i)
    s[i]=i;
  for (i=0; i<256; ++i) {
    j=j+s[i]+key[i%len]&255;
    swap(s[i], s[j]);
  }
  i=j=0;
  for (int k=0; k<10000; ++k)
    get();
}

// Get 1 byte of keystream
int RC4::get() {
  i=i+1&255;
  j=j+s[i]&255;
  swap(s[i], s[j]);
  return s[s[i]+s[j]&255];
}


/* Create and execute a random Turing machine and write its
output to out. A machine is a sequence of L=128 8 bit instructions,
a binary working tape, and an output bitsteam. An instruction is
formatted as:

   7, 6,5, 4,3, 2,1, 0
  c0,c1,w,wb,d,db,o,ob

If c0 is set, then the instruction is executed if the bit
read from the tape under the tape head is 0. If c1 is set,
then execute if it is a 1. If both bits are 0, the instruction
is a NOP. If both are 1, it is unconditional.

If w is set, then write wb to the tape. The tape is binary,
bidirectional, infinite in both directions, intialized to 0.

If d is set, then if db is 0 move the tape head left, else right.

If o is set, then output bit ob. Output is packed into bytes
in MSB to LSB order. Output ends with a 0 byte. If out is
stdout, output in uppercase hex ending with "00\n". After a 0 byte is
output, execution is halted (as an optimization) because further
execution would make no difference.

If the instruction is xx1xxx00 (w set, o and ob clear) then it is a
conditional jump to the address in the next byte. This means that
a jump must also write to the tape, may not output, and may optionally
move the tape head. (If the jump is conditional, then the same bit
can be written back to the tape). If the conditional jump is not taken,
then the next byte (containing the destination address) is skipped.
If the address space L is not 256 then the high bits of the destination
address are aligned with the high bits of the state. I.e. if the jump
address is A (8 bytes), the next state is set to A*L/256. For L=128,
the next state is A/2.

If the next state is 0, then halt before executing the instruction there.

A program executes for at most T=256 steps.

The program size is L=128 (must be a power of 2).
Execution starts at address 0 and proceeds sequentually mod L.
Jumps and addresses are computed mod L.

The global variables ends, timeouts, and halts are incremented depending
on whether the program output an end of string (0 byte), executed for T
steps, or executed a halt instruction (state 0).
*/

// Counters for reporting statistics
int ends=0, timeouts=0, halts=0;

void turing(FILE* out) {
  const int T=256;  // time limit
  const int L=128;  // program size, a power of 2
  unsigned char p[L]; // program (random)
  for (int i=0; i<L; ++i) p[i]=rc4.get();
  unsigned char tape[T*2];  // work tape, all 0 bits
  for (int i=0; i<T*2; ++i) tape[i]=0;
  int head=T;  // tape head
  int c=1;  // output byte with leading 1 bit
  int t=0;  // number of instructions
  int state=0;  // starting state

  // execute
  while (1) {
    assert(state>=0 && state<L);
    assert(head>=0 && head<T*2);
    int cmd=p[state];
    if (tape[head]==1 && (cmd&0x80) || tape[head]==0 && (cmd&0x40)) {
      if (cmd&0x20) tape[head]=cmd>>4&1;
      if (cmd&0x8) head+=(cmd>>1&2)-1;
      if (cmd&0x2) {
        c+=c+(cmd&1);
        if (c>=0x100) {
          if (c==0x100) {
            ++ends;
            break;
          }
          if (out==stdout) printf("%02X", c-0x100);
          else putc(c, out);
          c=1;
        }
      }
      if ((cmd&0x23)==0x20)
        state=((p[state+1&L-1])*L>>8)-1;  // jump
    }
    else if ((cmd&0x23)==0x20) ++state; // skip operand of jump not taken
    state=state+1&L-1;
    if (state==0) {
      ++halts;
      break;
    }
    if (++t==T) {
      ++timeouts;
      break;
    }
  }

  // output any remaining bits and trailing NUL
  while (c<0x100) c+=c;
  if (c>0x100) {
    if (out==stdout) printf("%02X", c-0x100);
    else putc(c, out);
  }
  if (out==stdout) printf("00\n");
  else putc(0, out);
}

int main(int argc, char** argv) {

  // Process command options
  char *f=0;      // output file name
  char *k=0;      // seed, default is random
  int n=1000000;  // number of outputs
  if (argc>1 && argv[1][0]!='-') f=argv[1];
  if (argc>2) k=argv[2];
  if (argc>3) n=atoi(argv[3]);
  if (argc<=1) {
    fprintf(stderr,
      "UIQ v2.1 universal compression test set generator.\n"
      "(C) 2008, Matt Mahoney.\n"
      "This is free software under GPL v3, www.gnu.org/copyleft/gpl.html\n"
      "\n"
      "To generate test data: uiq output [seed [n]]\n"
      "output = name of output file to be created. Use - for stdout in hex.\n"
      "seed = arbitrary string that determines the output.\n"
      "  On x86, default is to generate a random seed of 28 uppercase letters.\n"
      "n = number of output strings (1 to 33 bytes each), default 1000000.\n");
    exit(0);
  }

  // Don't clobber output file
  FILE *out=stdout;
  if (f) {
    out=fopen(f,"rb");
    if (out)
      fprintf(stderr, "Error: %s already exists.\n", f), exit(1);
  }

  // Seed random number generator
  char key[29];  // Generate and print 128+ bit key of uppercase letters
  if (k)
    rc4.init(k, strlen(k)+1);  // seed with key
  else {
    rc4.init(random256(), 256); // seed with hardware generated random string
    for (int i=0; i<28; ++i) {
      do
        key[i]=rc4.get();
      while (key[i]<'A' || key[i]>'Z');
    }
    key[28]=0;
    k=key;
    rc4.init(key, 29);
  }
  fprintf(stderr, "to re-create: uiq2 %s %s %d\n", f?f:"stdout", k, n);

  // Open output file
  if (f) {
    out=fopen(f,"wb");
    if (!out)
      perror(f), exit(1);
  }

  // Generate data
  while (n-->0)  // generate n output strings
    turing(out);
  fprintf(stderr, "%d programs halted, %d timed out, %d output premature NUL\n",
    halts, timeouts, ends);
  if (f) fprintf(stderr, "Created file %s\n", f);
  return 0;
}
