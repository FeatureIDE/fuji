/* Extended Type Check
 * 
 * IMPORTANT: 
 * add jar de.ovgu.featureide.fm.core...jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fuji's build-path
 * 
 * for tests (TestSuite.java):
 * add org.eclipse.equinox.common...jar (FM-Test 03)
 * add jakarta.jar (FM-Test 03)
 * add guidsl.jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fujis's build-path
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

import fuji.TypeErrorInfo;

aspect ExtendedTypeCheck {

	/* copied from ErrorCheck.jrag and modified: added "spl" or "Spl" 
	 * in front of method names or in method names
	 * added: FeatureModel in ASTNode
	 */

	public void ASTNode.collectSplErrors() {
		splTypeCheck();
		for(int i = 0; i < getNumChild(); i++) {
			getChild(i).collectSplErrors();
		}
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection, Collection warn) {	
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
				warn.addAll(cu.warnings);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
		warn.addAll(warnings);
	}

	/* /copy_&_modify */
	
	/* --- */

	/* the feature model */
	protected static FeatureModel ASTNode.featureModel;

	/* get the feature model */
	public FeatureModel ASTNode.getFeatureModel() {
		return featureModel;
	}

	/* set the feature model */
	public void ASTNode.setFeatureModel(FeatureModel model) {	
		featureModel = model;
	}
	
	/* (fromFeature ALWAYS toFeature) due to feature model */
	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	/* (fromFeature NEVER toFeature) due to feature model */
	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	/* (fromFeature MAYBE toFeature) due to feature model */
	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}
	
	/* for addSplError: 
	 * secondRound: relation of sourceHostType and targetHostType */
	protected static final int ASTNode.FIRST_ROUND = 0;
	protected static final int ASTNode.CLASS_EXTENDS_CLASS = 1;
	protected static final int ASTNode.CLASS_IMPLEMENTS_INTERFACE = 2;
	protected static final int ASTNode.INTERFACE_EXTENDS_INTERFACE = 3;
	
	/* checks for SPL errors in two rounds: (based on feature model)
	 * first round:
	 * check if at least one target (in declsAndTargetHostTypes) 
	 * is ALWAYS reachable from the feature fromFeatureID, i.e.
	 * if there is only one target:
	 * fromFeatureID is neither in MAYBE- nor in NEVER-dependency with target
	 * if there is more than one target: 
	 * at least one target is not optional 
	 * second round:
	 * check if at least one feature that has subtype information is ALWAYS 
	 * reachable from all features that do not have that subtype information
	 * but rely on that information to access fields, methods, constructors
	 * in a super type */
	public void ASTNode.addSplErrors(int fromFeatureID, 
			HashSet<Integer> contextPresentFeatures,
			HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes,
			String targetStructure, boolean isTypeAccess, TypeDecl sourceHostType,
			boolean secondRoundDone, int state,
			HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes,
			boolean isUnqualifiedAccess, TypeDecl narrowType,
			TypeDecl accessingType,
			HashMap<ASTNode, TypeDecl> accessingDeclsAndTargetHostTypes) {
		/* get the feature model */
		FeatureModel model = getFeatureModel();
		/* get dependencies from feature model */
		FeatureDependencies dep = new FeatureDependencies(model);
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(model.getConcreteFeatures());
		/* get targetHostTypes */
		HashSet<TypeDecl> targetHostTypes = new HashSet<TypeDecl>();
		targetHostTypes.addAll(declsAndTargetHostTypes.values());
		/* just one target (i.e. one decl) */
		if (declsAndTargetHostTypes.keySet().size() == 1) {
			/* get this decl */
			ASTNode decl = declsAndTargetHostTypes.keySet().iterator().next();
			/* get featureID of target */
			int toFeatureID = decl.featureID();
			/* get host type of target */
			TypeDecl targetHostType = declsAndTargetHostTypes.get(decl);
			/* OUTPUT */
			ASTNode outputDecl = outputDeclsAndTargetHostTypes.keySet().iterator()
					.next();
			String outputDeclString = outputDecl.toString();
			if (outputDecl instanceof ConstructorDecl) {
				ConstructorDecl cd = (ConstructorDecl) outputDecl;
				/* we have to build the output for a default constructor manually,
				 * because a default constructor is not pretty printed by
				 * JastAddJ */
				if (cd.isDefaultConstructor()) {
					StringBuffer s = new StringBuffer();
					cd.getModifiers().toString(s);
					outputDeclString = s.toString() + cd.name() + "()";
				}
			}
			TypeDecl outputTargetHostType = outputDeclsAndTargetHostTypes
					.get(outputDecl);
			String declFirstLine;
			if (isTypeAccess) {
				/* <package name (default:"(default package)")>.<type name> */
				declFirstLine = (targetHostType.packageName() != "" ? targetHostType
						.packageName() : "(default package)") + "." + targetHostType.name();
			} else {
				declFirstLine = (outputDeclString.indexOf("\n") == -1 ? outputDeclString
						: outputDeclString.substring(0, outputDeclString.indexOf("\n"))
						+ " ... }");
			}
			/* /OUTPUT */
			/* both features present? */
			if ((fromFeatureID != -1) && (toFeatureID != -1)) {
				/* different features? */
				if (fromFeatureID != toFeatureID) {
					Feature fromFeature = listFeatures.get(fromFeatureID);
					Feature toFeature = listFeatures.get(toFeatureID);
					boolean never = false;
					boolean maybe = false;
					/* if the context of selected features is formed by more than one
					 * feature, all of this features may influence the status of the 
					 * toFeature */
					if (contextPresentFeatures.size() > 1) {
						/* list of set of target feature */
						ArrayList<Set<Feature>> toFeatureList = new ArrayList<Set<Feature>>();
						HashSet<Feature> toFeatureSet = new HashSet<Feature>();
						toFeatureSet.add(toFeature);
						toFeatureList.add(toFeatureSet);
						/* form the context */
						HashSet<Feature> contextFeaturesSet = new HashSet<Feature>();
						/* next line is mostly redundant 
						 * (fromFeature should be included in contextPresentFeatures),
						 * just to get sure */
						contextFeaturesSet.add(fromFeature);
						for (int i : contextPresentFeatures) {
							if (i != -1) {
							  Feature contextFeature = listFeatures.get(i);
								contextFeaturesSet.add(contextFeature);
							}
						}
						try {
							/* context features selected, check status of toFeature */
							maybe = model.mayBeMissing(contextFeaturesSet, toFeatureList);
						} catch (TimeoutException e) {
							e.printStackTrace();
						}
					} else {
						/* fromFeature and toFeature cannot both occur in a valid product
						 * never-dep -> error */
						never = never(dep, fromFeature, toFeature);
						/* toFeature can, but doesn't have to occur in a valid product
						 * maybe-dep -> error */
						maybe = maybe(dep, fromFeature, toFeature);
					}
					/* OUTPUT */
					StringBuilder sbtei = new StringBuilder();
					/*
					 * for TypeAccess: list all source file names and line numbers, where
					 * a TypeAccess to a specific type takes place
					 */
					if (isTypeAccess) {
						if (typeAccesses != null) {
							HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> outerMap = typeAccesses.get(fromFeatureID);
							if (outerMap != null) {
								HashMap<TypeDecl, TypeErrorInfo> innerMap = outerMap.get(accessingType);
								if (innerMap != null) {
									if (accessingDeclsAndTargetHostTypes.keySet().iterator().hasNext()) {
										TypeDecl accessingTargetHostType = accessingDeclsAndTargetHostTypes
												.get(accessingDeclsAndTargetHostTypes.keySet().iterator().next());
										TypeErrorInfo tei = innerMap.get(accessingTargetHostType);
										if (tei != null) {
											for (String s : tei.getAccessSourceInfo()) {
												sbtei.append(s);
												sbtei.append("\n");
											}
											/* remove last "\n" */
											sbtei.setLength(sbtei.length() - 1);
										}
									}
								}
							}
						}
					}					
					StringBuilder sb = new StringBuilder();				
					if (never) {		
						sb.append("NEVER dependency:");
					}	else if (maybe) {									
						sb.append("MAYBE dependency:");
					}	
					if (never || maybe) {
						if (state == FIRST_ROUND) {
							sb.append("\nFeature ");
							sb.append(fromFeature.getName());
							sb.append(" accesses ");
							sb.append(targetStructure);
							sb.append("\n  ");
							sb.append(declFirstLine);
							sb.append("\nof feature ");
							sb.append(toFeature.getName());
							sb.append(".\n");
						} else {
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("\nClass ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("\nInterface ");
							}
							sb.append(sourceHostType.name() + " of feature ");
							sb.append(fromFeature.getName());
							sb.append(" accesses ");
							if (isTypeAccess) {
								if (state == CLASS_EXTENDS_CLASS) {
									sb.append("the instance");
								} else if ((state == CLASS_IMPLEMENTS_INTERFACE)
										|| (state == INTERFACE_EXTENDS_INTERFACE)) {
									sb.append("the implementation");
								}
							} else {
								sb.append(targetStructure);
							}
							sb.append("\n  ");
							sb.append(declFirstLine);
							sb.append("\nwhich is accessible via ");
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append("class ");
							} else if ((state == CLASS_IMPLEMENTS_INTERFACE)
									|| (state == INTERFACE_EXTENDS_INTERFACE)) {
								sb.append("interface ");
							}
							sb.append(outputTargetHostType.name() + ".\n");
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("Class ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("Interface ");
							}
							sb.append(sourceHostType.name() + " of feature ");
							sb.append(toFeature.getName());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" extends class ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" implements interface ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" extends interface ");
							}
							sb.append(outputTargetHostType.name() + ".\n");
							sb.append("The information that ");
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("class ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("interface ");
							}
							sb.append(sourceHostType.name());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" extends class ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" implements interface ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" extends interface ");
							}
							sb.append(outputTargetHostType.name());
							sb.append(" is only present in feature ");
							sb.append(toFeature.getName() + ".\n");
						}
					}			
					if (never) {
						sb.append("Features ");
						sb.append(fromFeature.getName());
						sb.append(" and ");
						sb.append(toFeature.getName());
						sb.append(" cannot both be present in a valid selection.\n");
					} else if (maybe) {
						sb.append("Feature ");
						sb.append(toFeature.getName());
						sb.append(" may not be present in every valid selection.\n");
					}
					if (never || maybe) {
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
					/* /OUTPUT */
				}
			}
			/* more than one target */
		} else if (declsAndTargetHostTypes.keySet().size() > 1) {
			HashSet<Integer> toFeatureIDs = new HashSet<Integer>();
			HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();
			/* for every target */
			for (Iterator iter = declsAndTargetHostTypes.keySet().iterator(); iter
					.hasNext();) {
				/* get target */
				ASTNode var = (ASTNode) iter.next();
				/* add its featureID */
				toFeatureIDs.add(var.featureID());
				TypeDecl targetHostType = declsAndTargetHostTypes.get(var);
				/* OUTPUT */
				String declFirstLine;
				if (isTypeAccess) {
					/* <package name (default: "(default package)")>.<type name> */
					declFirstLine = (targetHostType.packageName() != "" ? targetHostType
							.packageName() : "(default package)") + "." + targetHostType.name();
				} else {
					String declString = var.toString();
					if (var instanceof ConstructorDecl) {
						ConstructorDecl cd = (ConstructorDecl) var;
						/* we have to build the output for a default constructor manually */
						if (cd.isDefaultConstructor()) {
							StringBuffer s = new StringBuffer();
							cd.getModifiers().toString(s);
							declString = s.toString() + cd.name() + "()";
						}
					}
					declFirstLine = (declString.indexOf("\n") == -1 ? declString
							: declString.substring(0, declString.indexOf("\n")) + " ... }");
				}
				mapDecls.put(var.featureID(), declFirstLine);
			}
			HashMap<Integer, String> outputMapDecls = new HashMap<Integer, String>();
			/* do the same for every output target */
			for (Iterator iter = outputDeclsAndTargetHostTypes.keySet().iterator(); iter
					.hasNext();) {
				/* get output target */
				ASTNode outputVar = (ASTNode) iter.next();
				TypeDecl outputTargetHostType = outputDeclsAndTargetHostTypes
						.get(outputVar);
				String declFirstLine;
				if (isTypeAccess) {
					/* <package name (default: "(default package)")>.<type name> */
					declFirstLine = (outputTargetHostType.packageName() != "" ? outputTargetHostType
							.packageName() : "(default package)")
							+ "." + outputTargetHostType.name();
				} else {
					String declString = outputVar.toString();
					if (outputVar instanceof ConstructorDecl) {
						ConstructorDecl cd = (ConstructorDecl) outputVar;
						/* we have to build the output for a default constructor manually */
						if (cd.isDefaultConstructor()) {
							StringBuffer sb = new StringBuffer();
							cd.getModifiers().toString(sb);
							declString = sb.toString() + cd.name() + "()";
						}
					}
					declFirstLine = (declString.indexOf("\n") == -1 ? declString
							: declString.substring(0, declString.indexOf("\n")) + " ... }");
				}
				outputMapDecls.put(outputVar.featureID(), declFirstLine);
				/* /OUTPUT */
			}
			/* source feature exists */
			if (fromFeatureID != -1) {
				Feature fromFeature = listFeatures.get(fromFeatureID);
				/* list of set of target features */
				ArrayList<Set<Feature>> toFeaturesList = new ArrayList<Set<Feature>>();
				for (int toFeatureID : toFeatureIDs) {
					/* target feature exists */
					if (toFeatureID != -1) {
						Feature toFeature = listFeatures.get(toFeatureID);
						HashSet<Feature> toFeatureSet = new HashSet<Feature>();
						toFeatureSet.add(toFeature);
						toFeaturesList.add(toFeatureSet);
					}
				}
				/* form the context */
				HashSet<Feature> contextFeaturesSet = new HashSet<Feature>();
				/* next line is mostly redundant 
				 * (fromFeature should be included in contextPresentFeatures),
				 * just to get sure */
				contextFeaturesSet.add(fromFeature);
				for (int i : contextPresentFeatures) {
					if (i != -1) {
					  Feature contextFeature = listFeatures.get(i);
						contextFeaturesSet.add(contextFeature);
					}
				}
				boolean mayBeMissing = false;
				try {
					/* all features optional, accessing feature selected */
					mayBeMissing = model.mayBeMissing(contextFeaturesSet, toFeaturesList);
				} catch (TimeoutException e) {
					e.printStackTrace();
				}
				/* OUTPUT */
				/*
				 * for TypeAccess: list all source file names and line numbers, where a
				 * TypeAccess to a specific type takes place
				 */
				StringBuilder sbtei = new StringBuilder();
				if (isTypeAccess) {
					if (typeAccesses != null) {
						HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> outerMap = typeAccesses.get(fromFeatureID);
						if (outerMap != null) {
							HashMap<TypeDecl, TypeErrorInfo> innerMap = outerMap.get(accessingType);
							if (innerMap != null) {
								if (accessingDeclsAndTargetHostTypes.keySet().iterator().hasNext()) {
									TypeDecl accessingTargetHostType = accessingDeclsAndTargetHostTypes
											.get(accessingDeclsAndTargetHostTypes.keySet().iterator().next());
									TypeErrorInfo tei = innerMap.get(accessingTargetHostType);
									if (tei != null) {
										for (String s : tei.getAccessSourceInfo()) {
											sbtei.append(s);
											sbtei.append("\n");
										}
										/* remove last "\n" */
										sbtei.setLength(sbtei.length() - 1);
									}
								}
							}
						}
					}
				}					
				if (mayBeMissing) {
					StringBuilder sb = new StringBuilder();
					sb.append(toFeatureIDs.size());
					if (toFeatureIDs.size() > 1) {
						sb.append(" optional targets ");
						sb.append("(there may be a valid selection ");
						sb.append("where none of these targets is present):\n");
					} else if (toFeatureIDs.size() == 1) {
						sb.append(" optional target:\n");
					}
					if (state == FIRST_ROUND) {
						sb.append("Feature ");
						sb.append(fromFeature.getName());
						sb.append(" accesses:\n");
						for (int toFeatureID : mapDecls.keySet()) {
							if (toFeatureID != -1) {
								sb.append("- " + targetStructure);
								String decl = mapDecls.get(toFeatureID);
								sb.append("\n    ");
								sb.append(decl);
								sb.append("\n  of feature ");
								sb.append(listFeatures.get(toFeatureID).getName());
								sb.append("\n");
							}
						}
					} else {
						if ((state == CLASS_EXTENDS_CLASS)
								|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
							sb.append("Class ");
						} else if (state == INTERFACE_EXTENDS_INTERFACE) {
							sb.append("Interface ");
						}
						sb.append(sourceHostType.name() + " of feature ");
						sb.append(fromFeature.getName());
						sb.append(" accesses:\n");
						for (int toFeatureID : mapDecls.keySet()) {
							if (toFeatureID != -1) {
								sb.append("- in feature ");
								sb.append(listFeatures.get(toFeatureID).getName());
								if (state == CLASS_EXTENDS_CLASS) {
									sb.append(" as subclass of class ");
								} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
									sb.append(" as implementation of interface ");
								} else if (state == INTERFACE_EXTENDS_INTERFACE) {
									sb.append(" as subinterface of interface ");
								}
								if (isTypeAccess) {
									sb.append(outputMapDecls.get(outputMapDecls.keySet().iterator()
											.next()));
								} else {
									sb.append(mapDecls.get(toFeatureID));
								}
								sb.append(" " + targetStructure + "\n     ");
								sb.append(outputMapDecls.get(outputMapDecls.keySet().iterator()
										.next()));
								if (state == CLASS_EXTENDS_CLASS) {
									sb.append("\n   of class ");
								} else if ((state == CLASS_IMPLEMENTS_INTERFACE)
										|| (state == INTERFACE_EXTENDS_INTERFACE)) {
									sb.append("\n   of interface ");
								}
								if (isTypeAccess) {
									sb.append(outputMapDecls.get(outputMapDecls.keySet().iterator()
											.next()));
								} else {
									sb.append(mapDecls.get(toFeatureID));
								}
								sb.append(".\n");
							}
						}
						sb.append("There may be a valid selection where none of the features ");
						int i = mapDecls.keySet().size();
						int j = 1;
						for (int toFeatureID : mapDecls.keySet()) {
							if (toFeatureID != -1) {
								sb.append(listFeatures.get(toFeatureID).getName());
								if ((j + 1) < i) {
									sb.append(", ");
								} else if ((j + 1) == i) {
									sb.append(" and ");
								}
								j++;
							}
						}
						sb.append(" is present.\n");
						sb.append("So it may be that the information that ");
						if (state == CLASS_EXTENDS_CLASS) {
							sb.append("class " + sourceHostType.name()
									+ " (transitively) extends the class(es) above ");
						} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
							sb.append("class " + sourceHostType.name()
									+ " (transitively) implements the interface(s) above ");
						} else if (state == INTERFACE_EXTENDS_INTERFACE) {
							sb.append("interface "
									+ sourceHostType.name()
									+ " (transitively) extends the interface(s) above ");
						}
						sb.append("is not present at all.\n");
					}
					if (isTypeAccess) {
						typeError(sbtei.toString(), sb.toString());
					} else {
						error(sb.toString());
					}
				}
				/* /OUTPUT */
			}
		}
		if (!(secondRoundDone)) {
			/* second Round */
			/* get all feature IDs*/
			HashSet<Integer> toFeatureIDs = new HashSet<Integer>();
			for (Iterator iter = declsAndTargetHostTypes.keySet().iterator(); iter
					.hasNext();) {
				ASTNode var = (ASTNode) iter.next();
				toFeatureIDs.add(var.featureID());
			}
			/* external access: move starting point of checks to narrow type */
			if (!(isUnqualifiedAccess)) {
				/* no more interest in accessing host type, get narrow type */
				sourceHostType = narrowType;
			}
			/* for all targets */
			for (TypeDecl top : targetHostTypes) {
				/* fromFeature present and no access to a standard type */
				if (fromFeatureID != -1 && !(toFeatureIDs.contains(-1))) {
					/* access to different host type */
					if (!(sourceHostType.equals(top))) {
						/* get paths in type hierarchy from source to target */
						HashMap<TypeDecl, HashSet<TypeDecl>> paths = getTypeHierarchyPaths(
								sourceHostType, top);
						/* there is at least one subtype relation */
						if (!(paths.isEmpty())) {
							/* check for every path if the information about 
							 * the subtype relation in every step is always available */
							for (TypeDecl nextTd : paths.get(sourceHostType)) {
								/* next line is mostly redundant 
								 * (fromFeature should be included in contextPresentFeatures),
								 * just to get sure */
								contextPresentFeatures.add(fromFeatureID);
								/* check <paths> in type hierarchy 
								 * from <sourceHostType> (bottom) to <top> 
								 * over <nextTd> (super types of bottom) */
								splErrorCheckAccessToSuperType(sourceHostType, nextTd, top, paths, 
										fromFeatureID, contextPresentFeatures, targetStructure, outputDeclsAndTargetHostTypes,
										isUnqualifiedAccess, narrowType, isTypeAccess, accessingType, accessingDeclsAndTargetHostTypes);
							}							
						}
					}
				}
			}
		}
	}
	
	/* find fromFeatureIDs that do not have subtype information that they rely on
	 * to access fields, methods, constructors in their super type */
	public void ASTNode.splErrorCheckAccessToSuperType(TypeDecl currentSourceHostType, 
  		TypeDecl td, TypeDecl top, HashMap<TypeDecl, HashSet<TypeDecl>> paths, 
  		int fromFeatureID, HashSet<Integer> contextPresentFeatures, String targetStructure, 
  		HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes,
  		boolean isUnqualifiedAccess, TypeDecl narrowType, boolean isTypeAccess,
  		TypeDecl accessingType, HashMap<ASTNode, TypeDecl> accessingDeclsAndTargetHostTypes) {
		/* get the feature model */
  	FeatureModel model = getFeatureModel();
		/* get dependencies from feature model */
		FeatureDependencies dep = new FeatureDependencies(model);
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(model.getConcreteFeatures());
		/* access from a class: check extends and implements */
		if (currentSourceHostType instanceof ClassDecl) {
			ClassDecl sc = (ClassDecl) currentSourceHostType;
			/* get all features of this class */
			HashSet<Integer> allFeatures = new HashSet<Integer>();
			for (BodyDecl bd : sc.getBodyDecls()) {
				if (bd.featureID() != -1) {
				  allFeatures.add(bd.featureID());
				}
			}
			/* access to a class */
			if (td instanceof ClassDecl) {
				/* get all features with extends info of this targetHostType */
				HashSet<Access> accesses = new HashSet<Access>();
				/* get preserved super class accesses */
				if (!(sc.getPreservedSuperClassAccess().isEmpty())) {
					for (Access ac : sc.getPreservedSuperClassAccess()) {
						if (ac.type().equals(td)) {
							accesses.add(ac);
						}
					}
				}
				/* get super class access */
				if (sc.hasSuperClassAccess()) {
					if (sc.getSuperClassAccess().type().equals(td)) {
						accesses.add(sc.getSuperClassAccess());
					}
				}
				/* if there is extends info of this targetHostType */
				if (!(accesses.isEmpty())) {
					HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
					for (Access ac : accesses) {
						featuresWithExtendInfo.add(ac.featureID());
					}
					/* if this is an internal access, i.e. field/method/type
					 * should be accessible from within this class/interface,
					 * check for missing extends information based on this
					 * feature and sourceHostType */
					if (isUnqualifiedAccess) {
						/* is the extends info of this targetHostType missing in
						 * this fromFeature? */
						if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
							HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
							for (Access ac : accesses) {
								accessesAndTargetHostTypes.put(ac, ac.hostType());
							}
							/* set of selected features for mayBeMissing-Check (second round), 
							 * accessing feature is trivially set */
							contextPresentFeatures.add(fromFeatureID);
							/* check for SPL errors: is the extends info ALWAYS available 
							 * from this fromFeature due to the feature model? */
							addSplErrors(fromFeatureID, contextPresentFeatures,
									accessesAndTargetHostTypes, targetStructure,
									isTypeAccess, currentSourceHostType, true,
									CLASS_EXTENDS_CLASS,
									outputDeclsAndTargetHostTypes, isUnqualifiedAccess,
									currentSourceHostType, accessingType, accessingDeclsAndTargetHostTypes);
						}
					} else {
						/* external access
						 * check if the extends info is
						 * missing in all features */
						for (int featureID : allFeatures) {
							if (!(featuresWithExtendInfo.contains(featureID))) {
								HashMap<ASTNode, TypeDecl> narrowTypeAccessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								for (Access ac : accesses) {
									narrowTypeAccessesAndTargetHostTypes.put(ac,
											ac.hostType());
								}
								HashMap<ASTNode, TypeDecl> nextTdAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								nextTdAndTargetHostTypes.put(outputDeclsAndTargetHostTypes.keySet().iterator().next(), td);
								/* set of selected features for mayBeMissing-Check (second round), 
								 * set both fromFeatureID and featureID */
								contextPresentFeatures.add(fromFeatureID);
								contextPresentFeatures.add(featureID);
								/* check for SPL errors, narrow type */
								addSplErrors(featureID, contextPresentFeatures, 
										narrowTypeAccessesAndTargetHostTypes,
										targetStructure, isTypeAccess, currentSourceHostType, true,
										CLASS_EXTENDS_CLASS,
										nextTdAndTargetHostTypes,
										isUnqualifiedAccess, narrowType, accessingType, accessingDeclsAndTargetHostTypes);
							}
						}
					}
				}
			}
			/* access to interface */
			if (td instanceof InterfaceDecl) {
				/* get all features with implements info of this
				 * targetHostType */
				HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
				if (sc.getNumImplements() != 0) {
					for (Access ac : sc.getImplementsList()) {
						if (ac.type().equals(td)) {
							accessesAndTargetHostTypes.put(ac, ac.hostType());
						}
					}
				}
				/* if there are features that implement the targetHostType */
				if (!(accessesAndTargetHostTypes.keySet().isEmpty())) {
					HashSet<Integer> featuresWithImplementInfo = new HashSet<Integer>();
					for (ASTNode ac : accessesAndTargetHostTypes.keySet()) {
						featuresWithImplementInfo.add(ac.featureID());
					}
					/* if this is an internal access, i.e. field/method/type
					 * should be accessible from within this class/interface,
					 * check for missing implements information based on this
					 * feature and sourceHostType */
					if (isUnqualifiedAccess) {
						/* is the implements info of this targetHostType missing
						 * in this fromFeature? */
						if (!(featuresWithImplementInfo.contains(fromFeatureID))) {
							/* set of selected features for mayBeMissing-Check (second round), 
							 * accessing feature is trivially set */
							contextPresentFeatures.add(fromFeatureID);
							/* check for SPL errors: is the implements info ALWAYS available 
							 * from this fromFeature due to the feature model? */
							addSplErrors(fromFeatureID, contextPresentFeatures,
									accessesAndTargetHostTypes, targetStructure,
									isTypeAccess, currentSourceHostType, true,
									CLASS_IMPLEMENTS_INTERFACE,
									outputDeclsAndTargetHostTypes, isUnqualifiedAccess,
									currentSourceHostType, accessingType, accessingDeclsAndTargetHostTypes);
						}
					} else {
						/* external access
						 * check if the implements info
						 * is missing in all features */
						for (int featureID : allFeatures) {
							if (!(featuresWithImplementInfo.contains(featureID))) {
								HashMap<ASTNode, TypeDecl> nextTdAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								nextTdAndTargetHostTypes.put(outputDeclsAndTargetHostTypes.keySet().iterator().next(), td);
								/* set of selected features for mayBeMissing-Check (second round), 
								 * set both fromFeatureID and featureID */
								contextPresentFeatures.add(fromFeatureID);
								contextPresentFeatures.add(featureID);
								/* check for SPL errors, narrow type */
								addSplErrors(featureID, contextPresentFeatures,
										accessesAndTargetHostTypes, targetStructure,
										isTypeAccess, currentSourceHostType, true,
										CLASS_IMPLEMENTS_INTERFACE,
										nextTdAndTargetHostTypes,
										isUnqualifiedAccess, narrowType, accessingType, accessingDeclsAndTargetHostTypes);
							}
						}
					}
				}
			}
		}
		/* access from an interface: check extends */
		if (currentSourceHostType instanceof InterfaceDecl) {
			/* access to interface */
			if (td instanceof InterfaceDecl) {
				InterfaceDecl si = (InterfaceDecl) currentSourceHostType;
				/* get all features of this interface */
				HashSet<Integer> allFeatures = new HashSet<Integer>();
				for (BodyDecl bd : si.getBodyDecls()) {
					if (bd.featureID() != -1) {
					  allFeatures.add(bd.featureID());
					}
				}
				/* get all feature with extends info of this targetHostType */
				HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
				if (si.getNumSuperInterfaceId() != 0) {
					for (Access ac : si.getSuperInterfaceIdList()) {
						if (ac.type().equals(td)) {
							accessesAndTargetHostTypes.put(ac, ac.hostType());
						}
					}
				}
				/* if there is extends info of this targetHostType */
				if (!(accessesAndTargetHostTypes.keySet().isEmpty())) {
					HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
					for (ASTNode ac : accessesAndTargetHostTypes.keySet()) {
						featuresWithExtendInfo.add(ac.featureID());
					}
					/* if this is an internal access, i.e. field/method/type
					 * should be accessible from within this class/interface,
					 * check for missing extends information based on this
					 * feature and sourceHostType */
					if (isUnqualifiedAccess) {
						/* is the extends info of this targetHostType missing in
						 * this fromFeature? */
						if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
							/* set of selected features for mayBeMissing-Check (second round), 
							 * accessing feature is trivially set */
							contextPresentFeatures.add(fromFeatureID);
							/* check for SPL errors: is the extends info ALWAYS available 
							 * from this fromFeature due to the feature model? */
							addSplErrors(fromFeatureID, contextPresentFeatures,
									accessesAndTargetHostTypes, targetStructure,
									isTypeAccess, currentSourceHostType, true,
									INTERFACE_EXTENDS_INTERFACE,
									outputDeclsAndTargetHostTypes, isUnqualifiedAccess,
									currentSourceHostType, accessingType, accessingDeclsAndTargetHostTypes);
						}
					} else {
						/* external access
						 * check if the extends info is
						 * missing in all features */
						for (int featureID : allFeatures) {
							if (!(featuresWithExtendInfo.contains(featureID))) {
								HashMap<ASTNode, TypeDecl> nextTdAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								nextTdAndTargetHostTypes.put(outputDeclsAndTargetHostTypes.keySet().iterator().next(), td);
								/* set of selected features for mayBeMissing-Check (second round), 
								 * set both fromFeatureID and featureID */
								contextPresentFeatures.add(fromFeatureID);
								contextPresentFeatures.add(featureID);
								/* check for SPL errors, narrow type */
								addSplErrors(featureID, contextPresentFeatures,
										accessesAndTargetHostTypes, targetStructure,
										isTypeAccess, currentSourceHostType, true,
										INTERFACE_EXTENDS_INTERFACE,
										nextTdAndTargetHostTypes,
										isUnqualifiedAccess, narrowType, accessingType, accessingDeclsAndTargetHostTypes);
							}
						}
					}
				}
			}
		}
		/* we didn't reach the top yet, go up in the type hierarchy 
		 * and look for similar errors */
		if (!(td.equals(top))) {
			/* different ways up */
			for (TypeDecl nextTd : paths.get(currentSourceHostType)) {
				/* recursive call: go up the type hierarchy */
				splErrorCheckAccessToSuperType(td, nextTd, top, paths, fromFeatureID, 
						contextPresentFeatures,
						targetStructure, outputDeclsAndTargetHostTypes, isUnqualifiedAccess,
						narrowType, isTypeAccess, accessingType, accessingDeclsAndTargetHostTypes);
			}
		}
	}
	
	/* is this type (= bottom) in the type hierarchy beneath 
	 * another type (= top) */
	public boolean TypeDecl.isInTypeHierarchy(TypeDecl topType) {
		boolean isInTypeHierarchy = false;
		if (this.equals(topType)) {
			/* relation is reflexive, TODO necessary ? */
			isInTypeHierarchy = true;
		} else {
			HashSet<Access> accesses = new HashSet<Access>();
			if (this instanceof ClassDecl) {
				ClassDecl cd = (ClassDecl) this;
				/* get extends information */
				if (!(cd.getPreservedSuperClassAccess().isEmpty())) {
					accesses.addAll(cd.getPreservedSuperClassAccess());
				}
				if (cd.hasSuperClassAccess()) {
					accesses.add(cd.getSuperClassAccess());
				}
				/* get implements information */
				if (cd.getNumImplements() != 0) {
					for (Access ac : cd.getImplementsList()) {
						accesses.add(ac);
					}
				}
			} else if (this instanceof InterfaceDecl) {
				InterfaceDecl id = (InterfaceDecl) this;
				/* get extends information*/
				if (id.getNumSuperInterfaceId() != 0) {
					for (Access ac : id.getSuperInterfaceIdList()) {
						accesses.add(ac);
					}
				}
			}
			HashSet<TypeDecl> accessHostTypes = new HashSet<TypeDecl>();
			if (!(accesses.isEmpty())) {
				for (Access ac : accesses) {
					if (ac instanceof TypeAccess) {
						TypeAccess tac = (TypeAccess) ac;
						accessHostTypes.add(tac.decl().hostType());
					}
				}
			}
			if (!(accessHostTypes.isEmpty())) {
				if (accessHostTypes.contains(topType)) {
					/* found in this step */
					isInTypeHierarchy = true;
				} else {
					for (TypeDecl td : accessHostTypes) {
						/* recursive step */
						isInTypeHierarchy |= td.isInTypeHierarchy(topType);
					}
				}		
			}
		}
		return isInTypeHierarchy;
	}
	
	/* list the paths in the type hierarchy from bottomType to topType; 
	 * returns an empty map if there are no paths; 
	 * the key points to all supertypes of this type */
	public HashMap<TypeDecl, HashSet<TypeDecl>> ASTNode.getTypeHierarchyPaths(TypeDecl bottomType, TypeDecl topType) {
		HashMap<TypeDecl, HashSet<TypeDecl>> paths = new HashMap<TypeDecl, HashSet<TypeDecl>>();
		HashSet<TypeDecl> superTypes = new HashSet<TypeDecl>();
		if (bottomType.equals(topType)) {
			/* relation is reflexive, TODO: neccessary ? */
			superTypes.add(topType);
			paths.put(bottomType, superTypes);
		} else {
			HashSet<Access> accesses = new HashSet<Access>();
			if (bottomType instanceof ClassDecl) {
				ClassDecl cd = (ClassDecl) bottomType;
				/* get extends information (Class) */
				if (!(cd.getPreservedSuperClassAccess().isEmpty())) {
					accesses.addAll(cd.getPreservedSuperClassAccess());
				}
				if (cd.hasSuperClassAccess()) {
					accesses.add(cd.getSuperClassAccess());
				}
				/* get implements information (Class) */
				if (cd.getNumImplements() != 0) {
					for (Access ac : cd.getImplementsList()) {
						accesses.add(ac);
					}
				}
			} else if (bottomType instanceof InterfaceDecl) {
				InterfaceDecl ifd = (InterfaceDecl) bottomType;
				/* get extends information (Interface) */
				if (ifd.getNumSuperInterfaceId() != 0) {
					for (Access ac : ifd.getSuperInterfaceIdList()) {
						accesses.add(ac);
					}
				}
			}
			HashSet<TypeDecl> accessHostTypes = new HashSet<TypeDecl>();
			if (!(accesses.isEmpty())) {
				for (Access ac : accesses) {
					if (ac instanceof TypeAccess) {
						TypeAccess tac = (TypeAccess) ac;
						accessHostTypes.add(tac.decl().hostType());
					}
				}
			}
			if (!(accessHostTypes.isEmpty())) {
				if (accessHostTypes.contains(topType)) {
					/* direct super type found, stop here */
					superTypes.add(topType);
					paths.put(bottomType, superTypes);
				} else {
					boolean nextStepOK = false;
					for (TypeDecl td : accessHostTypes) {
						/* recursive step */
						HashMap<TypeDecl, HashSet<TypeDecl>> nextStep = getTypeHierarchyPaths(td, topType);
						if (!(nextStep.isEmpty())) {
							nextStepOK = true;
							paths.putAll(nextStep);
							superTypes.add(td);
						}
					}
					if (nextStepOK) {
						/* add beginning of path */
						paths.put(bottomType, superTypes);
					}
				}
			}
		}
		return paths;
	}
	
	/* --- */
	
	/* collect all TypeAccesses in a Map 
	 * format: 
	 * map: (fromFeatureID, map: (sourceHostType, map: (targetHostType, TypeErrorInfo)))
	 * (TypeErrorInfo decls: accesses to constructors of this type 
   * and source file name and line number of these type accesses) */
	protected static HashMap<Integer, HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>> ASTNode.typeAccesses =
	new HashMap<Integer, HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>>();

	/* for type accesses */
	protected ArrayList Program.errors = new ArrayList();

	/* for type accesses */
	protected ArrayList Program.warnings = new ArrayList();
	
	/* report a type error
	 * correct line number and file name */
	public void ASTNode.typeError(String accessSourceInfo, String msg) {
		ASTNode node = this;
		while(node != null && !(node instanceof Program))
			node = node.getParent();
		Program pr = (Program) node;
		pr.errors.add(new Problem(accessSourceInfo, msg, 
				Problem.Severity.ERROR, Problem.Kind.SEMANTIC));
	}

	/* line numbers included in fileName */
	public Problem.Problem(String fileName, String message, Severity severity, Kind kind) {
		this(fileName, message);
		this.kind = kind;
		this.severity = severity;
	}
	
	/* analyse collected Type Accesses */
	public void ASTNode.collectSplTypeErrors() {
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(featureModel.getConcreteFeatures());
		/* for all fromFeatureIDs that need types */
		for (int i : typeAccesses.keySet()) {
			Feature fromFeature = listFeatures.get(i);
			if (!(typeAccesses.get(i).isEmpty())) {
				HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> typesAndInfo = typeAccesses.get(i);
				if (!(typesAndInfo.keySet().isEmpty())) {
					/* for all sourceHostTypes where a type is needed in this feature */
					for (TypeDecl sourceHostType : typesAndInfo.keySet()) {
						HashMap<TypeDecl, TypeErrorInfo> innerTypeAndInfo = typesAndInfo.get(sourceHostType);
						if (!(innerTypeAndInfo.keySet().isEmpty())) {
							/* for all targetHostTypes needed by this sourceHostType in this feature */
							for (TypeDecl targetHostType : innerTypeAndInfo.keySet()) {
								/* get type accesses to contructors of the needed type */
								SimpleSet decls = innerTypeAndInfo.get(targetHostType).getDecls();
								/* wrap together type accesses and the needed type */
								HashMap<ASTNode, TypeDecl> declsAndTargetHostType = new HashMap<ASTNode, TypeDecl>();
								for (Iterator iter = decls.iterator(); iter.hasNext(); ) {
								  declsAndTargetHostType.put((ASTNode) iter.next(), targetHostType);
								}
								/* set of selected features for mayBeMissing-Check (second round), 
								 * accessing feature is trivially set */
								HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
								contextPresentFeatures.add(i);
								/* check for SPL errors */
								addSplErrors(i, contextPresentFeatures, declsAndTargetHostType, "the type", true, sourceHostType, false, FIRST_ROUND, declsAndTargetHostType,
										innerTypeAndInfo.get(targetHostType).isUnqualifiedAccess(), sourceHostType, sourceHostType, declsAndTargetHostType);
							}
						}
					}
				}
			}
		}
	}

	/* placeholder */
	public void ASTNode.splTypeCheck() { }

	/* Field Accesses */
	public void VarAccess.splTypeCheck() {
		/* from java.ast: VarAccess : Access ::= <ID:String>; */
		/* is the VarAccess a FieldAccess? */
		if (isFieldAccess()) {
		    
		    /* Simple type check. */
		    /* Name check.  See JastAddJ/Java1.4Frontend/NameCheck.jrag:VarAccess.nameCheck() */
		    if(decls().isEmpty() && (!isQualified() || !qualifier().type().isUnknown() || qualifier().isPackageAccess())) {
		        error("no field named " + name());
		        return;
		    }
		    
		    /* Variablility-aware type check */
		    if (getSPLStructure().hasVariability()) {
    			HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    			for (Iterator iter = decls().iterator(); iter.hasNext(); ) {
    				BodyDecl decl = (BodyDecl) iter.next();
    				declsAndTargetHostTypes.put(decl, decl.hostType());
    			}
    			TypeDecl narrowType = hostType();
    			if (isQualified()) {
    				Expr expr = qualifier();
    				if (expr instanceof VarAccess) {
    					VarAccess varAc = (VarAccess) expr;
    					if (varAc.decl() instanceof VariableDeclaration) {
    						VariableDeclaration vd = (VariableDeclaration) varAc.decl();
    						if (vd.hasInit()) {
    							narrowType = vd.getInit().type();
    						} else {
    							narrowType = vd.type();
    						}
    					} else if (varAc.decl() instanceof FieldDeclaration) {
    						FieldDeclaration fd = (FieldDeclaration) varAc.decl();
    						if (fd.hasInit()) {
    							narrowType = fd.getInit().type();
    						} else {
    							narrowType = fd.type();
    						}
    					}
    				} else if (expr instanceof TypeAccess) {
    					TypeAccess typeAc = (TypeAccess) expr;
    					narrowType = typeAc.type();
    				} else if (expr instanceof ClassInstanceExpr) {
    					ClassInstanceExpr cie = (ClassInstanceExpr) expr;
    					narrowType = cie.type();
    				} else if (expr instanceof ParExpr) {
    					ParExpr parExpr = (ParExpr) expr;
    					narrowType = parExpr.type();
    					if (parExpr.getExpr() instanceof CastExpr) {
    						CastExpr ce = (CastExpr) parExpr.getExpr();
    						narrowType = ce.getExpr().type();
    					}
    				}
    			}
    			/* set of selected features for mayBeMissing-Check (second round), 
    			 * accessing feature is trivially set */
    			HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    			contextPresentFeatures.add(featureID());
    			/* check for SPL errors */
    			addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, "the field", false,
    					hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
    					(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
    					narrowType, hostType(), declsAndTargetHostTypes);
		    }
		}
	}

	/* Method Accesses */
	public void MethodAccess.splTypeCheck() {
	    String ORIGINAL_ACCESS = "original";
	    
	    /* Simle type check. */
	    /* Name check.  See JastAddJ/Java1.4Frontend/NameCheck.jrag:MethodAccess.nameCheck() */
	    if (name().equals(ORIGINAL_ACCESS) && !getProgram().ignoreOriginal()) {
	        /* get context, i.e. method signature of the method 
             * where the access comes from */
            String context = ((MethodDecl) enclosingBodyDecl()).signature();
            /* get all methods with the same signature in this type 
             * that are in another feature */
            boolean isThereOrigialTarget = false;
            for (BodyDecl bd : hostType().getBodyDecls()) {
                if (bd instanceof MethodDecl) {
                    MethodDecl md = (MethodDecl) bd;
                    if (md.signature().equals(context) && (md.featureID() != featureID())) {
                        isThereOrigialTarget = true;
                        break;
                    }
                }
            }
            if (!isThereOrigialTarget) {
                error("no original-method found in " + methodHost() + ".");
                return;
            }
	    } else {
//	        boolean isDeclarationPresent = false;
//	        for (BodyDecl bd : decl().hostType().getBodyDecls()) {
//	            if (bd instanceof MethodDecl) {
//	                if (((MethodDecl) bd).signature().equals(decl().signature())) {
//	                    isDeclarationPresent = true;
//	                }
//	            }
//	        }
	        if(decls().isEmpty() && (!isQualified() || !qualifier().isUnknown())) {
	            StringBuffer s = new StringBuffer();
	            s.append("no method named " + name());
	            s.append("(");
	            for(int i = 0; i < getNumArg(); i++) {
	              if(i != 0)
	                s.append(", ");
	              s.append(getArg(i).type().typeName());
	            }
	            s.append(")" + " in " + methodHost() + " matches.");
	            error(s.toString());
	            return;
	        }
	    }
	    
	    /* Variability-aware type check. */
	    if (getSPLStructure().hasVariability()) {
    		/* from java.ast: MethodAccess : Access ::= <ID:String> Arg:Expr*; */
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		/* original-check: if the target method is named "original",
    		 * then in this type (in another feature) 
    		 * there should be a method with the same signature as the method where
    		 * this access comes from */
    		if (name().equals(ORIGINAL_ACCESS)) {
    			/* get context, i.e. method signature of the method 
    			 * where the access comes from */
    			String context = ((MethodDecl) enclosingBodyDecl()).signature();
    			/* get all methods with the same signature in this type 
    			 * that are in another feature */
    			for (BodyDecl bd : hostType().getBodyDecls()) {
    				if (bd instanceof MethodDecl) {
    					MethodDecl md = (MethodDecl) bd;
    					if (md.signature().equals(context) && (md.featureID() != featureID())) {
    						declsAndTargetHostTypes.put(md, md.hostType());
    					}
    				}
    			}
    			StringBuffer s = new StringBuffer();
    			s.append("with original-call\n    ");
    			s.append(name());
    			s.append("(");
    			for (int i = 0; i < getNumArg(); i++) {
    				if (i != 0) { s.append(", "); }
    				s.append(getArg(i).type().typeName());
    			}
    			s.append(")");
    			s.append("\n  in method\n    " + context + "\n  of type " + methodHost());
    			s.append("\n  method");
    			/* set of selected features for mayBeMissing-Check (second round), 
    			 * accessing feature is trivially set */
    			HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    			contextPresentFeatures.add(featureID());
    			/* check for SPL errors */
    			addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, s.toString(), false,
    					hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, !(isQualified()), hostType(), hostType(), declsAndTargetHostTypes);
    			/* check, if types of arguments fit the method declaration 
    			 * (i.e. check, if the information that the type of an argument is 
    			 * a subtype of the expected parameter is always available due to 
    			 * the feature model) */
    			for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
    				if (decl instanceof MethodDecl) {
    					MethodDecl md = (MethodDecl) decl;
    					for (int i = 0; i < getNumArg() & i < md.getNumParameter(); i++) {
    						/* different types of argument and parameter */						
    						if (!((getArg(i).type()).equals((md.getParameter(i).type())))) {
    							HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    							/* get all bodyDecls of this type, and thus all features 
    							 * that implement this type */
    							for (BodyDecl bd : md.getParameter(i).type().getBodyDecls()) {
    							  	typeDeclsAndTargetHostTypes.put(bd, bd.hostType());
    							}
      						/* for output: type of parameter */
      						HashMap<ASTNode, TypeDecl> typeOfParameter = new HashMap<ASTNode, TypeDecl>();
      						typeOfParameter.put(md.getParameter(i).type(), md.getParameter(i).type().hostType());
    							/* check for SPL errors */
    							addSplErrors(featureID(), contextPresentFeatures, typeDeclsAndTargetHostTypes, 
    									"(by an implicit cast from argument to parameter type) the type", false, hostType(), 
    									false, FIRST_ROUND, typeOfParameter, false, getArg(i).type(), hostType(), declsAndTargetHostTypes);
    						}					
    					}
    				}
    			}
    		} else {
    			/* get all methods with the same signature as the needed method
    			 * in this type */
    			for (BodyDecl bd : decl().hostType().getBodyDecls()) {
    				if (bd instanceof MethodDecl) {
    					if (((MethodDecl) bd).signature().equals(decl().signature())) {
    						declsAndTargetHostTypes.put(bd, bd.hostType());
    					}
    				}
    			}
    			TypeDecl narrowType = hostType();
    			if (isQualified()) {
    				Expr expr = qualifier();
    				if (expr instanceof VarAccess) {
    					VarAccess varAc = (VarAccess) expr;
    					if (varAc.decl() instanceof VariableDeclaration) {
    						VariableDeclaration vd = (VariableDeclaration) varAc.decl();
    						if (vd.hasInit()) {
    							narrowType = vd.getInit().type();
    						} else {
    							narrowType = vd.type();
    						}
    					} else if (varAc.decl() instanceof FieldDeclaration) {
    						FieldDeclaration fd = (FieldDeclaration) varAc.decl();
    						if (fd.hasInit()) {
    							narrowType = fd.getInit().type();
    						} else {
    							narrowType = fd.type();
    						}
    					}
    				} else if (expr instanceof TypeAccess) {
    					TypeAccess typeAc = (TypeAccess) expr;
    					narrowType = typeAc.type();
    				} else if (expr instanceof ClassInstanceExpr) {
    					ClassInstanceExpr cie = (ClassInstanceExpr) expr;
    					narrowType = cie.type();
    				} else if (expr instanceof ParExpr) {
    					ParExpr parExpr = (ParExpr) expr;
    					narrowType = parExpr.type();
    					if (parExpr.getExpr() instanceof CastExpr) {
    						CastExpr ce = (CastExpr) parExpr.getExpr();
    						narrowType = ce.getExpr().type();
    					}
    				}
    			}
    			/* set of selected features for mayBeMissing-Check (second round), 
    			 * accessing feature is trivially set */
    			HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    			contextPresentFeatures.add(featureID());
    			/* check for SPL errors */
    			addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, "the method",
    					false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
    					(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
    					narrowType, hostType(), declsAndTargetHostTypes);
    			/* check, if types of arguments fit the method declaration 
    			 * (i.e. check, if the information that the type of an argument is 
    			 * a subtype of the expected parameter is always available due to 
    			 * the feature model) */
    			for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
    				if (decl instanceof MethodDecl) {
    					MethodDecl md = (MethodDecl) decl;
    					for (int i = 0; i < getNumArg() & i < md.getNumParameter(); i++) {
    						/* different types of argument and parameter */
    						if (!((getArg(i).type()).equals((md.getParameter(i).type())))) {
    							HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    							/* get all bodyDecls of this type, and thus all features 
    							 * that implement this type */
    							for (BodyDecl bd : md.getParameter(i).type().getBodyDecls()) {
    							  	typeDeclsAndTargetHostTypes.put(bd, bd.hostType());
    							}
      						/* for output: type of parameter */
      						HashMap<ASTNode, TypeDecl> typeOfParameter = new HashMap<ASTNode, TypeDecl>();
      						typeOfParameter.put(md.getParameter(i).type(), md.getParameter(i).type().hostType());
    							/* check for SPL errors */
    							addSplErrors(featureID(), contextPresentFeatures, typeDeclsAndTargetHostTypes, 
    									"(by an implicit cast from argument type to parameter type) the type", false, hostType(), 
    									false, FIRST_ROUND, typeOfParameter, false, getArg(i).type(), hostType(), declsAndTargetHostTypes);
    						}
    					}
    				}
    			}
    		}
	    }
	}

	/* Type Accesses */
	public void TypeAccess.splTypeCheck() {
	    
        /* Simle type check. */
        /* Name check.  See JastAddJ/Java1.4Frontend/NameCheck.jrag:TypeAccess.nameCheck() */
        if (this.hostType() != null) { // exclude ImportDecls
            if(decls().isEmpty()) {
                error("no visible type named " + typeName());
                return;
            }
        }

	    /* Variability-aware type check. */
        if (getSPLStructure().hasVariability()) {
    		/* from java.ast: TypeAccess : Access ::= <Package:String> <ID:String>; */
    		/* collect all TypeAccesses: source feature, type, decl(s), source file(s),
    		 * line number(s) */
    		int fromFeatureID = featureID();
    		/* ignore importDecl */
    		if (isRaw()) {
    			/* do not collect default types */
    			if (!(fromFeatureID == -1) && !(decl().featureID() == -1) && !(hostType().featureID() == -1) && !(decl().hostType().featureID() == -1)) {
    				HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> typesAndInfo = typeAccesses.get(fromFeatureID);
    				if (typesAndInfo == null) {
    					typesAndInfo = new HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>();
    				}
    				HashMap<TypeDecl, TypeErrorInfo> innerTypeAndInfo = typesAndInfo.get(hostType());
    				if (innerTypeAndInfo == null) {
    					innerTypeAndInfo = new HashMap<TypeDecl, TypeErrorInfo>();
    				}
    				/* add all bodyDecls of this type 
    				 * to get the featureIDs of all features that implement this type */
    				HashSet<BodyDecl> listDecls = new HashSet<BodyDecl>();
    				for (BodyDecl bd : decl().hostType().getBodyDecls()) {
    						listDecls.add(bd);
    				}
    				TypeErrorInfo tei = innerTypeAndInfo.get(decl().hostType());
    				if (tei == null) {
    					tei = new TypeErrorInfo(new SimpleSet.SimpleSetImpl(listDecls), new HashSet<String>(), 
    							(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()));
    				} else {
    					for (Iterator iter = tei.getDecls().iterator(); iter.hasNext(); ) {
    						listDecls.add((BodyDecl) iter.next());
    					}
    					tei.setDecls(new SimpleSet.SimpleSetImpl(listDecls));
    				}
    				/* save source file and line number of type access */
    				tei.getAccessSourceInfo().add(sourceFile() + ":" + lineNumber());
    				innerTypeAndInfo.put(decl().hostType(), tei);
    				typesAndInfo.put(hostType(), innerTypeAndInfo);
    				typeAccesses.put(fromFeatureID, typesAndInfo);
    			}
    		}
        }
	}

	/* Class Instance Expr, keyword new
	 * Constructor Access does not work properly (?) */
	public void ClassInstanceExpr.splTypeCheck() {

	    /* Simple type check. */
        /* Name check.  See JastAddJ/Java1.4Frontend/NameCheck.jrag:ClassInstanceExpr.nameCheck() */
	    if(decls().isEmpty()) {
	        error("can not instantiate " + type().typeName() + " no matching constructor found in " + type().typeName());
	        return;
	    }

	    /* Variability aware type check. */
	    if (getSPLStructure().hasVariability()) {
    		/* from java.ast: ClassInstanceExpr : Access ::= Access Arg:Expr* [TypeDecl]; */
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		/* get all constructors with the same signature in this type */
    		for (BodyDecl bd : decl().hostType().getBodyDecls()) {
    			if (bd instanceof ConstructorDecl) {
    				if (((ConstructorDecl) bd).signature().equals(decl().signature())) {
    					declsAndTargetHostTypes.put((ConstructorDecl) bd, decl().hostType());
    				}
    			}
    		}
    		/* set of selected features for mayBeMissing-Check (second round), 
    		 * accessing feature is trivially set */
    		HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    		contextPresentFeatures.add(featureID());
    		/* check for SPL errors */
    		addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, "the constructor",
    				false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
    				(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
    				decl().hostType(), hostType(), declsAndTargetHostTypes);
    		/* check, if types of arguments fit the constructor declaration 
    		 * (i.e. check, if the information that the type of an argument is 
    		 * a subtype of the expected parameter is always available due to 
    		 * the feature model) */
    		for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
    			if (decl instanceof ConstructorDecl) {
    				ConstructorDecl cd = (ConstructorDecl) decl;
    				for (int i = 0; i < getNumArg() & i < cd.getNumParameter(); i++) {
    					/* different types of argument and parameter */
    					if (!((getArg(i).type()).equals((cd.getParameter(i).type())))) {
    						HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    						/* get all bodyDecls of this type, and thus all features 
    						 * that implement this type */
    						for (BodyDecl bd : cd.getParameter(i).type().getBodyDecls()) {
    						  	typeDeclsAndTargetHostTypes.put(bd, bd.hostType());
    						}
    						/* for output: type of parameter */
    						HashMap<ASTNode, TypeDecl> typeOfParameter = new HashMap<ASTNode, TypeDecl>();
    						typeOfParameter.put(cd.getParameter(i).type(), cd.getParameter(i).type().hostType());
    						/* check for SPL errors */
    						addSplErrors(featureID(), contextPresentFeatures, typeDeclsAndTargetHostTypes, 
    								"(by an implicit cast from argument type to parameter type) the type", false, hostType(), 
    								false, FIRST_ROUND, typeOfParameter, false, getArg(i).type(), hostType(), declsAndTargetHostTypes);
    					}				
    				}
    			}
    		}
	    }
	}
	
	
	/*
	 * Casts
	 */
	
	/* Declaration of Field with implicit upcast */
	public void FieldDeclaration.splTypeCheck() {
	    
	    /* Simple type check. */
	    /* Type check.  See /home/kolesnik/work/projects/fuji/FujiProject/branches/fuji-typesystem/FujiCompiler/lib/JastAddJ/Java1.4Frontend/TypeCheck.jrag:FieldDeclaration.typeCheck() */
	    
        /* 
         * TODO: what if there is a simple type error, there is no an spl-type error,
         * and not all features are mandatory.  Do simple and var-aware checks, reutrn warning if the simple check returned an error and var-aware not.
         */
	    if(hasInit() && !getSPLStructure().hasVariability()) {
	        TypeDecl source = getInit().type();
	        TypeDecl dest = type();
	        if(!source.assignConversionTo(dest, getInit())) {
	            error("can not assign " + name() + " of type " + dest.typeName() +
	                    " a value of type " + source.typeName());
	            return;
	        }
	    }
	    
	    /* Variability aware type check. */
        if (getSPLStructure().hasVariability()) {
    		/* from java.ast: FieldDeclaration : MemberDecl ::= Modifiers TypeAccess:Access <ID:String> [Init:Expr]; // Simplified FieldDecl */
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		if (hasInit()) {
    			TypeDecl sourceType = getInit().type();
    			TypeDecl targetType = type();
    			if (!(sourceType.equals(targetType))) {
    				declsAndTargetHostTypes.put(getInit(), targetType);
    				outputDeclsAndTargetHostTypes.put(targetType, targetType);
    				/* set of selected features for mayBeMissing-Check (second round), 
    				 * accessing feature is trivially set */
    				HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    				contextPresentFeatures.add(featureID());
    				/* check for SPL errors */
    				addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, 
    						"(by an implicit cast/in the type hierarchy) the type",
    						false, hostType(), false, FIRST_ROUND, outputDeclsAndTargetHostTypes, false, sourceType, hostType(), declsAndTargetHostTypes);
    			}
    		}
		}
	}
	
	/* Declaration of Variable with implicit upcast */
	public void VariableDeclaration.splTypeCheck() {

	    /* Simple type check. */
        /* Type check.  See /home/kolesnik/work/projects/fuji/FujiProject/branches/fuji-typesystem/FujiCompiler/lib/JastAddJ/Java1.4Frontend/TypeCheck.jrag:VariableDeclaration.splTypeCheck() */
        /* 
	     * TODO: what if there is a simple type error, there is no an spl-type error,
	     * and not all features are mandatory. 
	     */
	    if(hasInit() && !getSPLStructure().hasVariability()) {
	        TypeDecl source = getInit().type();
	        TypeDecl dest = type();
	        if(!source.assignConversionTo(dest, getInit())) {
	            error("can not assign " + name() + " of type " + dest.typeName() +
	                    " a value of type " + source.typeName());
	            return;
	        }
	    }
	    
	    /* Variability aware type check. */
	    if (getSPLStructure().hasVariability()) {
    		/* from java.ast: VariableDeclaration : Stmt ::= Modifiers TypeAccess:Access <ID:String> [Init:Expr]; // Simplified VarDeclStmt */
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		if (hasInit()) {
    			TypeDecl sourceType = getInit().type();
    			TypeDecl targetType = type();
    			if (!(sourceType.equals(targetType))) {
    				declsAndTargetHostTypes.put(getInit(), targetType);
    				outputDeclsAndTargetHostTypes.put(targetType, targetType);
    				/* set of selected features for mayBeMissing-Check (second round), 
    				 * accessing feature is trivially set */
    				HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    				contextPresentFeatures.add(featureID());
    				/* check for SPL errors */
    				addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, 
    						"(by an implicit cast/in the type hierarchy) the type",
    						false, hostType(), false, FIRST_ROUND, outputDeclsAndTargetHostTypes, false, sourceType, hostType(), declsAndTargetHostTypes);
    			}
    		}
	    }
	}
	
	/* Simple Assignment with implicit upcast */
	public void AssignSimpleExpr.splTypeCheck() {

	    /* Simple type check. */
        /* Type check.  See /home/kolesnik/work/projects/fuji/FujiProject/branches/fuji-typesystem/FujiCompiler/lib/JastAddJ/Java1.4Frontend/TypeCheck.jrag:AssignSimpleExpr.splTypeCheck() */
        /* 
         * TODO: what if there is a simple type error, there is no an spl-type error,
         * and not all features are mandatory. 
         */
	    if (!getSPLStructure().hasVariability()) {
    	    if(!sourceType().assignConversionTo(getDest().type(), getSource()) && !sourceType().isUnknown()) {
    	        error("can not assign " + getDest() + " of type " + getDest().type().typeName() +
    	              " a value of type " + sourceType().typeName());
    	    }
	    }
	    
	    /* Variability aware type check. */
        if (getSPLStructure().hasVariability()) {

            /* from java.ast: AssignSimpleExpr : AssignExpr ; */
    		/* report a type error, if a type is implicitly casted to a
    		 * supertype in this assignment and the information 
    		 * of this subtype relation is only available in features that 
    		 * are all optional or mutual exclusive to the selected feature 
    		 * (so there could be a valid feature selection where the information 
    		 * of this subtype relation is not present) */
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		/* from java.ast: 
    		 * abstract AssignExpr : Expr ::= Dest:Expr Source:Expr; */
    		TypeDecl sourceType = getSource().type(); /* right hand side of "=" */
    		TypeDecl targetType = getDest().type();   /* left  hand side of "=" */
    		/* implicit cast */
    		if (!(sourceType.equals(targetType))) {
    			declsAndTargetHostTypes.put(getSource(), targetType);
    			outputDeclsAndTargetHostTypes.put(targetType, targetType);
    			/* set of selected features for mayBeMissing-Check (second round), 
    			 * accessing feature is trivially set */
    			HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    			contextPresentFeatures.add(featureID());
    			/* check for SPL errors */
    			addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, 
    					"(by an implicit cast/in the type hierarchy) the type",
    					false, hostType(), false, FIRST_ROUND, outputDeclsAndTargetHostTypes, false, sourceType, hostType(), declsAndTargetHostTypes);
    		}
		}
	}

	/* handle up- and downcasts */
	public void CastExpr.splTypeCheck() {
	    
	    /* Simple type check. */
        /* Type check.  See /home/kolesnik/work/projects/fuji/FujiProject/branches/fuji-typesystem/FujiCompiler/lib/JastAddJ/Java1.4Frontend/TypeCheck.jrag:CastExpr.splTypeCheck() */
        /* 
         * TODO: what if there is a simple type error, there is no an spl-type error,
         * and not all features are mandatory. 
         */
	    if (!getSPLStructure().hasVariability()) {
	        TypeDecl expr = getExpr().type();
	        TypeDecl type = getTypeAccess().type();
	        if(!expr.isUnknown()) {
	            if(!expr.castingConversionTo(type)) {
	                error(expr.typeName() + " can not be cast into " + type.typeName());
	            }
	        }
	    }
	    
	    /* Variability aware type check. */
        if (getSPLStructure().hasVariability()) {
    
    		/* from java.ast: CastExpr : Expr ::= TypeAccess:Access Expr; */
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		Access ac = getTypeAccess();
    		if (ac instanceof TypeAccess) {
    		    TypeAccess ta = (TypeAccess) ac;
    		    /* different types */
          		if (!(getExpr().type().equals(ta.decl()))) {
          			if (getExpr().type().isInTypeHierarchy(ta.decl())) {
          				/* Expr side of CastExpr is in type hierarchy beneath 
          				 * the TypeAccess side => upcast */
          				/* get all bodyDecls of this type, and thus all features 
        					 * that implement this type */
        					for (BodyDecl bd : ta.decl().getBodyDecls()) {
        						declsAndTargetHostTypes.put(bd, bd.hostType());
        					}
        					/* set of selected features for mayBeMissing-Check (second round), 
        					 * accessing feature is trivially set */
        					HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
        					contextPresentFeatures.add(featureID());
        					/* type access for output */
        					HashMap<ASTNode, TypeDecl> typeDeclAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
        					typeDeclAndTargetHostTypes.put(ta.decl(), ta.decl().hostType());
          				/* check for SPL errors */
          				addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, "by a cast the type", false, hostType(), 
          						false, FIRST_ROUND, typeDeclAndTargetHostTypes, false, getExpr().type(), hostType(), typeDeclAndTargetHostTypes);
          			} else if (ta.decl().isInTypeHierarchy(getExpr().type())) {
          				/* TypeAccess side of CastExpr is in type hierarchy beneath 
          				 * the Expr side => downcast */
          				declsAndTargetHostTypes.put(getExpr().type(), getExpr().type().hostType());
          				/* set of selected features for mayBeMissing-Check (second round), 
          				 * accessing feature is trivially set */
          				HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
          				contextPresentFeatures.add(featureID());
          				/* check for SPL errors */
          				addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, "by a cast the type", false, hostType(), 
          						false, FIRST_ROUND, declsAndTargetHostTypes, false, ta.decl(), hostType(), declsAndTargetHostTypes);
          			}
          		}
      	    }
        }
	}
	
	/* Super Constructor Access (also implicit in Default Constructor) */
	public void SuperConstructorAccess.splTypeCheck() {
	    
	    /* Simple type check. */
        /* Type check.  See */
        /* 
         * TODO: what if there is a simple type error, there is no an spl-type error,
         * and not all features are mandatory. 
         */
        if (!getSPLStructure().hasVariability()) {
            //TODO
        }

        /* Variability aware type check. */
        if (getSPLStructure().hasVariability()) {
    		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    		/* do not consider trivial super constructor accesses 
    		 * (i.e. class has no super class but Object) */
    		if (!(decl().hostType().name().equals("Object"))) {
    			/* get all bodyDecls of this type, and thus all features 
    			 * that implement this type */
    			for (BodyDecl bd : decl().hostType().getBodyDecls()) {
    				if (bd instanceof ConstructorDecl) {
    					ConstructorDecl cd = (ConstructorDecl) bd;
    					declsAndTargetHostTypes.put(cd, cd.hostType());
    				}		
    			}
    		}
    		/* if there are non-trivial super constructor accesses */
    		if (!(declsAndTargetHostTypes.keySet().isEmpty())) {
    			/* set of selected features for mayBeMissing-Check (second round), 
    			 * accessing feature is trivially set */
    			HashSet<Integer> contextPresentFeatures = new HashSet<Integer>();
    			contextPresentFeatures.add(featureID());
    			/* check for SPL errors: this is an unqualified access */
    			addSplErrors(featureID(), contextPresentFeatures, declsAndTargetHostTypes, 
    					"the super constructor", false, hostType(), 
    					false, FIRST_ROUND, declsAndTargetHostTypes, true, hostType(), hostType(), declsAndTargetHostTypes);
    			/* check, if types of arguments fit the constructor declaration 
    			 * (i.e. check, if the information that the type of an argument is 
    			 * a subtype of the expected parameter is always available due to 
    			 * the feature model) */
    			for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
    				if (decl instanceof ConstructorDecl) {
    					ConstructorDecl cd = (ConstructorDecl) decl;
    					for (int i = 0; i < getNumArg() & i < cd.getNumParameter(); i++) {
    						/* different types of argument and parameter */
    						if (!((getArg(i).type()).equals((cd.getParameter(i).type())))) {
    							HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
    							/* get all bodyDecls of this type, and thus all features 
    							 * that implement this type */
    							for (BodyDecl bd : cd.getParameter(i).type().getBodyDecls()) {
    							  	typeDeclsAndTargetHostTypes.put(bd, bd.hostType());
    							}
      						/* for output: type of parameter */
      						HashMap<ASTNode, TypeDecl> typeOfParameter = new HashMap<ASTNode, TypeDecl>();
      						typeOfParameter.put(cd.getParameter(i).type(), cd.getParameter(i).type().hostType());
    							/* check for SPL errors */
    							addSplErrors(featureID(), contextPresentFeatures, typeDeclsAndTargetHostTypes, 
    									"(by an implicit cast from argument type to parameter type) the type", false, hostType(), 
    									false, FIRST_ROUND, typeOfParameter, false, getArg(i).type(), hostType(), declsAndTargetHostTypes);
    						}						
    					}
    				}
    			}
    		}
    	}
	}
}