/* Extended Type Check
 * 2012-04-14
 * 
 * IPORTANT: 
 * add jar de.ovgu.featureide.fm.core... (FM-Test 03)
 * to Fuji's build-path
 * 
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.nameCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * (MethodAccess.nameCheck())
 * - checks, if one feature tries to access a method of a second feature
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 *   
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

aspect ExtendedTypeCheck {
	
	refine NameCheck public void VarAccess.nameCheck() {
	
		// NameCheck.VarAccess.nameCheck();
		
		/* copy&paste */	
	    if(decls().isEmpty() && (!isQualified() || !qualifier().type().isUnknown() || qualifier().isPackageAccess()))
	      error("no field named " + name());
	    if(decls().size() > 1) {
	      StringBuffer s = new StringBuffer();
	      s.append("several fields named " + name());
	      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
	        Variable v = (Variable)iter.next();
	        s.append("\n    " + v.type().typeName() + "." + v.name() + " declared in " + v.hostType().typeName());
	      }
	      error(s.toString());
	    }
	      
	    // 8.8.5.1
	    if(inExplicitConstructorInvocation() && !isQualified() && decl().isInstanceVariable() && hostType() == decl().hostType())
	      error("instance variable " + name() + " may not be accessed in an explicit constructor invocation");

	    Variable v = decl();
	    if(!v.isFinal() && !v.isClassVariable() && !v.isInstanceVariable() && v.hostType() != hostType())
	      error("A parameter/variable used but not declared in an inner class must be declared final");

	    // 8.3.2.3
	    if((decl().isInstanceVariable() || decl().isClassVariable()) && !isQualified()) {
	      if(hostType() != null && !hostType().declaredBeforeUse(decl(), this)) {
	        if(inSameInitializer() && !simpleAssignment() && inDeclaringClass()) {
	          BodyDecl b = closestBodyDecl(hostType());
	          error("variable " + decl().name() + " is used in " + b + " before it is declared");
	        }
	      }
	    }	    
	    /* /copy&paste */
	    
	    /* new */	    
	    /* TODO: file name from outside
	     * read in Feature-Model */
	    FeatureModel model = new FeatureModel();
	    File guidsl_file = new File("model.m");

		GuidslReader reader = new GuidslReader(model);
		try {
	      reader.readFromFile(guidsl_file);
		} catch (FileNotFoundException e) {
		  e.printStackTrace();
		} catch (UnsupportedModelException e) {
		  e.printStackTrace();
		}
		
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());
	    
		  /* Ist der Variablenzugriff ein Feldzugriff? */
		  if (isFieldAccess()) {
			int fromFeatureID = featureID();
			int toFeatureID = decl().hostType().featureID();
				
			/* beide Features vorhanden? */
			if(fromFeatureID != -1 && toFeatureID != -1) {
				
			  /* Wird auf ein anderes Feature zugegriffen? */
			  if (!(fromFeatureID == toFeatureID)) {
			    /*
				 * Auf Reihenfolge Features aus dem FM zu
				 * Feature(-ID)s aus dem AST achten!
				 */				
				Feature fromFeature = model.getFeature(listFeatures
				  .get(fromFeatureID).getName());
					 
				Feature toFeature = model.getFeature(listFeatures
				  .get(toFeatureID).getName());					 
										
				/* mit SAT-Solver testen, ob dieser Umstand 
				 * (Zugriff auf Feld in optionalem Feature)
				 * als zusŠtzliches Constraint im FM berŸcksichtigt 
				 * wurde: fromFeature implies toFeature 
				 * falls ja: okay
				 * falls nein: Fehlermeldung
				 *  (oder HinzufŸgen des Constraints zum FM)
				 */
						
				FeatureDependencies dep = new FeatureDependencies(model);	 
					 
				if(never(dep, fromFeature, toFeature)) {
				  /*
				   * Zugriff auf ein Feld in einem Feature
				   * gefunden, das in gegenseitigem Ausschluss steht
				   * -> Fehlermeldung
				   */					
				  error("gegenseitiger Ausschluss:" 
						+ "\n    Feature " + fromFeature.getName()
						+ " greift auf das Feld\n      " + decl()
						+ "\n    des Features "
						+ toFeature.getName() + " zu.\n    "
						+ fromFeature.getName() + " und "
						+ toFeature.getName()
						+ " schlie§en sich aber "
						+ "gegenseitig aus.\n");
				}
					
				if(maybe(dep, fromFeature, toFeature)) {
				  /*
				   * Zugriff auf ein Feld in einem optionalen Feature
				   * gefunden -> Fehlermeldung
				   */					
				  error("Zugriff auf Feld in einem optionalen Feature:"
						+ "\n    Feature " + fromFeature.getName()
						+ " greift auf das Feld\n      " + decl()
						+ "\n    des optionalen Features "
						+ toFeature.getName() + " zu.\n");
				}
			  }
			}
		  }	
	      /* /new */    
	  }
	
	  protected boolean ASTNode.always(FeatureDependencies dep, 
			                           Feature fromFeature, 
			                           Feature toFeature) {		  	  
		  return dep.always(fromFeature).contains(toFeature);
	  }

	  protected boolean ASTNode.never(FeatureDependencies dep,
			                          Feature fromFeature,
			                          Feature toFeature) {
		  return dep.never(fromFeature).contains(toFeature);
	  }
	  
	  /* TODO: check */
	  protected boolean ASTNode.sometimes(FeatureDependencies dep,
			                              Feature fromFeature,
			                              Feature toFeature) {
		  return !(always(dep, fromFeature, toFeature)) &&
				  !(never(dep, fromFeature, toFeature));
	  }
	  
	  protected boolean ASTNode.maybe(FeatureDependencies dep,
			                          Feature fromFeature,
			                          Feature toFeature) {
		  return dep.maybe(fromFeature).contains(toFeature);
	  }
	  
	  refine MethodSignature15 public void MethodAccess.typeCheck() {
		  
		    /* copy&paste */
		    if(isQualified() && decl().isAbstract() && qualifier().isSuperAccess())
		        error("may not access abstract methods in superclass");
		      if(!decl().isVariableArity() || invokesVariableArityAsArray()) {
		        for(int i = 0; i < decl().getNumParameter(); i++) {
		          TypeDecl exprType = getArg(i).type();
		          TypeDecl parmType = decl().getParameter(i).type();
		          if(!exprType.methodInvocationConversionTo(parmType) && !exprType.isUnknown() && !parmType.isUnknown()) {
		            error("#The type " + exprType.typeName() + " of expr " +
		              getArg(i) + " is not compatible with the method parameter " +
		              decl().getParameter(i));
		          }
		        }
		      }
		      /* /copy&paste */
		      
		      /* new */
		      /* TODO: file name from outside
			     * read in Feature-Model */
			    FeatureModel model = new FeatureModel();
			    File guidsl_file = new File("model.m");

				GuidslReader reader = new GuidslReader(model);
				try {
			      reader.readFromFile(guidsl_file);
				} catch (FileNotFoundException e) {
				  e.printStackTrace();
				} catch (UnsupportedModelException e) {
				  e.printStackTrace();
				}
				
				/* get features */
				ArrayList<Feature> listFeatures = new ArrayList<Feature>();
				/* TODO: werden hierdurch ALLE benoetigten Features in der 
				 * richtigen REIHENFOLGE eingelesen? */
				listFeatures.addAll(model.getConcreteFeatures());
				
				int fromFeatureID = featureID();
				int toFeatureID = decl().hostType().featureID();
					
				/* beide Features vorhanden? */
				if(fromFeatureID != -1 && toFeatureID != -1) {
					
				  /* Wird auf ein anderes Feature zugegriffen? */
				  if (!(fromFeatureID == toFeatureID)) {
				    /*
					 * Auf Reihenfolge Features aus dem FM zu
					 * Feature(-ID)s aus dem AST achten!
					 */				
					Feature fromFeature = model.getFeature(listFeatures
					  .get(fromFeatureID).getName());
						 
					Feature toFeature = model.getFeature(listFeatures
					  .get(toFeatureID).getName());					 
											
					/* mit SAT-Solver testen, ob dieser Umstand 
					 * (Zugriff auf Feld in optionalem Feature)
					 * als zusŠtzliches Constraint im FM berŸcksichtigt 
					 * wurde: fromFeature implies toFeature 
					 * falls ja: okay
					 * falls nein: Fehlermeldung
					 *  (oder HinzufŸgen des Constraints zum FM)
					 */
							
					FeatureDependencies dep = new FeatureDependencies(model);	 
						 
					if(never(dep, fromFeature, toFeature)) {
					  /*
					   * Zugriff auf eine Methode in einem Feature
					   * gefunden, das in gegenseitigem Ausschluss steht
					   * -> Fehlermeldung
					   */					
					  error("gegenseitiger Ausschluss:" 
							+ "\n    Feature " + fromFeature.getName()
							+ " greift auf die Methode\n\n  " + decl()
							+ "\n\n    des Features "
							+ toFeature.getName() + " zu.\n    "
							+ fromFeature.getName() + " und "
							+ toFeature.getName()
							+ " schlie§en sich aber "
							+ "gegenseitig aus.\n");
					}
						
					if(maybe(dep, fromFeature, toFeature)) {
					  /*
					   * Zugriff auf eine Methode in einem optionalen Feature
					   * gefunden -> Fehlermeldung
					   */					
					  error("Zugriff auf Methode in einem optionalen Feature:"
							+ "\n    Feature " + fromFeature.getName()
							+ " greift auf die Methode\n\n  " + decl()
							+ "\n\n    des optionalen Features "
							+ toFeature.getName() + " zu.\n");
					}
				  }
				}
				
		      /* /new */
	  }
}