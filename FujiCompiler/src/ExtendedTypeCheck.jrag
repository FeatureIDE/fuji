/* Extended Type Check
 * 2012-11-17
 * 
 * IMPORTANT: 
 * add jar de.ovgu.featureide.fm.core...jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fuji's build-path
 * 
 * for tests (TestSuite.java):
 * add org.eclipse.equinox.common...jar (FM-Test 03)
 * add jakarta.jar (FM-Test 03)
 * add guidsl.jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fujis's build-path
 * 
 * TODO: rewrite
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.splTypeCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * - when two or more features provide an implementation for a type and 
 *   all of them are optional, then it would be possible, that no implementation
 *   of the type is present. 
 * (MethodAccess.splTypeCheck())
 * - checks, if one feature tries to access a method of a second feature
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * - when two or more features provide an implementation for a type and 
 *   all of them are optional, then it would be possible, that no implementation
 *   of the type is present.
 * (TypeAccess.splTypeCheck())
 * - collect all type accesses and check, if all required types are present
 *   in at least one feature each
 *   - types, classes, interfaces, Generics, (try, catch, throw)
 *   - Cast, Constructor,
 *   - 4 types of inner classes (static, member, local, anonymous)
 * (ClassInstanceExpr.splTypeCheck())
 * - ...
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

import fuji.TypeErrorInfo;

aspect ExtendedTypeCheck {

	/* the feature model */
	protected static FeatureModel ASTNode.featureModel;

	public FeatureModel ASTNode.getFeatureModel() {
		return featureModel;
	}

	public void ASTNode.setFeatureModel(FeatureModel model) {	
		featureModel = model;
	}

	/* collect all TypeAccesses in a Map 
	 * format: 
	 * map: fromFeatureID, map: sourceHostType, map: targetHostType, TypeErrorInfo
	 * (decls: accesses to constructors of this type 
   * and source file name and line number of these type accesses) */
	protected static HashMap<Integer, HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>> ASTNode.typeAccesses =
	new HashMap<Integer, HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>>();

	/* for type accesses */
	protected ArrayList Program.errors = new ArrayList();

	/* for type accesses */
	protected ArrayList Program.warnings = new ArrayList();
	
	/* for addSplError */
	protected static final int ASTNode.FIRST_ROUND = 0;
	protected static final int ASTNode.CLASS_EXTENDS_CLASS = 1;
	protected static final int ASTNode.CLASS_IMPLEMENTS_INTERFACE = 2;
	protected static final int ASTNode.INTERFACE_EXTENDS_INTERFACE = 3;

	/* report a type error */
	/* correct line number and file name */
	public void ASTNode.typeError(String accessSourceInfo, String msg) {
		ASTNode node = this;
		while(node != null && !(node instanceof Program))
			node = node.getParent();
		Program pr = (Program)node;
		pr.errors.add(new Problem(accessSourceInfo, msg, 
				Problem.Severity.ERROR, Problem.Kind.SEMANTIC));
	}

	/* line numbers included in fileName */
	public Problem.Problem(String fileName, String message, Severity severity, Kind kind) {
		this(fileName, message);
		this.kind = kind;
		this.severity = severity;
	}

	/* (fromFeature ALWAYS toFeature) due to feature model */
	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	/* (fromFeature NEVER toFeature) due to feature model */
	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	/* (fromFeature MAYBE toFeature) due to feature model */
	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}

	/* collect Type Errors */
	public void ASTNode.collectSplTypeErrors() {
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(featureModel.getConcreteFeatures());
		/* for all fromFeatureIDs that need types */
		for (int i : typeAccesses.keySet()) {
			Feature fromFeature = listFeatures.get(i);
			if (!(typeAccesses.get(i).isEmpty())) {
				HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> typesAndInfo = typeAccesses.get(i);
				if (!(typesAndInfo.keySet().isEmpty())) {
					/* for all sourceHostTypes where a type is needed in this feature */
					for (TypeDecl sourceHostType : typesAndInfo.keySet()) {
						HashMap<TypeDecl, TypeErrorInfo> innerTypeAndInfo = typesAndInfo.get(sourceHostType);
						if (!(innerTypeAndInfo.keySet().isEmpty())) {
							/* for all targetHostTypes needed by this feature */
							for (TypeDecl targetHostType : innerTypeAndInfo.keySet()) {
								/* get type accesses to contructors of the needed type */
								SimpleSet decls = innerTypeAndInfo.get(targetHostType).getDecls();
								/* wrap together type accesses and the needed type */
								HashMap<ASTNode, TypeDecl> declsAndTargetHostType = new HashMap<ASTNode, TypeDecl>();
								for (Iterator iter = decls.iterator(); iter.hasNext(); ) {
								  declsAndTargetHostType.put((ASTNode) iter.next(), targetHostType);
								}
								/* check for SPL errors */
								addSplErrors(i, declsAndTargetHostType, "auf den Typ", true, sourceHostType, false, FIRST_ROUND, declsAndTargetHostType,
										innerTypeAndInfo.get(targetHostType).isUndottedAccess());
							}
						}
					}
				}
			}
		}
	}

	/* copied from ErrorCheck.jrag and modified: added "spl" or "Spl" 
	 * in front of method names or in method names
	 * added: FeatureModel in ASTNode
	 * TODO: get sure, that the featureModel is properly initiated.
	 */

	/* */
	public void ASTNode.collectSplErrors() {
		splTypeCheck();
		for(int i = 0; i < getNumChild(); i++) {
			getChild(i).collectSplErrors();
		}
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection, Collection warn) {	
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
				warn.addAll(cu.warnings);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
		warn.addAll(warnings);
	}

	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		collectSplErrors();
		collection.addAll(errors);
	}

	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection err, Collection warn) {		
		setFeatureModel(model);
		collectSplErrors();
		err.addAll(errors);
		warn.addAll(warnings);
	}

	public boolean Program.splErrorCheck(FeatureModel model) {		
		Collection collection = new LinkedList();
		splErrorCheck(model, collection);
		if(collection.isEmpty()) {
			return false;
		}
		System.out.println("SPL Errors:");
		for(Iterator iter = collection.iterator(); iter.hasNext(); ) {
			String s = (String)iter.next();
			System.out.println(s);
		}
		return true;
	}

	/* /copy_&_modify */

	public void ASTNode.addSplErrors(int fromFeatureID,
			HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes,
			String targetStructure, boolean isTypeAccess, TypeDecl sourceHostType,
			boolean secondRoundDone, int state, HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes,
			boolean isUndottedAccess) {
		FeatureModel model = getFeatureModel();
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(model.getConcreteFeatures());
		/* get targetHostTypes */
		HashSet<TypeDecl> targetHostTypes = new HashSet<TypeDecl>();
		for (Iterator iter = declsAndTargetHostTypes.keySet().iterator(); iter.hasNext(); ) {
			TypeDecl targetHostType = declsAndTargetHostTypes.get((ASTNode) iter.next());
			targetHostTypes.add(targetHostType);
		}
		/* just one target */
		if (declsAndTargetHostTypes.keySet().size() == 1) {
			ASTNode decl = declsAndTargetHostTypes.keySet().iterator().next();
			int toFeatureID = decl.featureID();
			TypeDecl targetHostType = (TypeDecl) declsAndTargetHostTypes.get(decl).iterator().next();
			ASTNode outputDecl = outputDeclsAndTargetHostTypes.keySet().iterator().next();
			String outputDeclString = outputDecl.toString();
			TypeDecl outputTargetHostType = (TypeDecl) outputDeclsAndTargetHostTypes.get(outputDecl).iterator().next();
			String declFirstLine;
			if (isTypeAccess) {
				/* <package name (default:"(default package)")>.<type name> */
				declFirstLine = ( targetHostType.packageName() != "" 
						? targetHostType.packageName() 
						: "(default package)" ) + "." + targetHostType.name();
			} else {
				declFirstLine = ( outputDeclString.indexOf("\n") == -1 ? outputDeclString
						: outputDeclString.substring(0, outputDeclString.indexOf("\n")) + " ... }" );
			}
			/* both features present? */
			if ((fromFeatureID != -1) && (toFeatureID != -1)) {
				/* different features? */
				if (fromFeatureID != toFeatureID) {
					Feature fromFeature = listFeatures.get(fromFeatureID);
					Feature toFeature = listFeatures.get(toFeatureID);
					/* get dependencies from feature model */
					FeatureDependencies dep = new FeatureDependencies(model);
					/* for TypeAccess: list all source file names and line numbers, where a
					 * TypeAccess to a specific type takes place */
					StringBuilder sbtei = new StringBuilder();
					if (isTypeAccess) {
						TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(sourceHostType).get(targetHostType);
						for (String s : tei.getAccessSourceInfo()) {
							sbtei.append(s);
							sbtei.append("\n");
						}
						sbtei.setLength(sbtei.length() - 1);
					}
					/* fromFeature and toFeature cannot both occur in a valid product 
					 * never-dep -> error */
					if (never(dep, fromFeature, toFeature)) {
						StringBuilder sb = new StringBuilder();
						sb.append("never-Beziehung:");
						if (state == FIRST_ROUND) {
							sb.append("\nDas Feature ");
							sb.append(fromFeature.getName());
							sb.append(" greift ");
							sb.append(targetStructure);
							sb.append("\n  ");
							sb.append(declFirstLine);
							sb.append("\ndes Features ");
							sb.append(toFeature.getName());
							sb.append(" zu.\n");
						} else {
							if ((state == CLASS_EXTENDS_CLASS) || (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("\nDie Klasse ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("\nDas Interface ");
							}
							sb.append(sourceHostType.name() + " des Features ");
							sb.append(fromFeature.getName());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" greift als Unterklasse der Klasse ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" greift als Implementierung des Interfaces ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" greift als Sub-Interface des Interfaces ");
							}
							sb.append(outputTargetHostType.name() + " ");
							sb.append(targetStructure);
							sb.append("\n  ");
							sb.append(declFirstLine);
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append("\nder Klasse ");
							} else if ((state == CLASS_IMPLEMENTS_INTERFACE) || (state == INTERFACE_EXTENDS_INTERFACE)) {
								sb.append("\ndes Interfaces ");
							}
							sb.append(outputTargetHostType.name() + " zu.\n");
							sb.append("Die Information, dass ");
							if ((state == CLASS_EXTENDS_CLASS) || (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("die Klasse ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("das Interface ");
							}
							sb.append(sourceHostType.name());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" eine Unterklasse der Klasse ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" eine Implementierung des Interfaces ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" ein Sub-Interface des Interfaces ");
							}
							sb.append(outputTargetHostType.name());
							sb.append(" ist, ist nur im Feature ");
							sb.append(toFeature.getName() + " vorhanden.\n");
						}
						sb.append("Die Features ");
						sb.append(fromFeature.getName());
						sb.append(" und ");
						sb.append(toFeature.getName());
						sb.append(" koennen aber ");
						sb.append("nicht beide gleichzeitig in einer validen ");
						sb.append("Auswahl vorkommen.\n");
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
					/* toFeature can, but doesn't have to occur in a valid product
					 * maybe-dep -> error */
					if (maybe(dep, fromFeature, toFeature)) {
						StringBuilder sb = new StringBuilder();
						sb.append("maybe-Beziehung:");
						if (state == FIRST_ROUND) {
							sb.append("\nDas Feature ");
							sb.append(fromFeature.getName());
							sb.append(" greift ");
							sb.append(targetStructure);
							sb.append("\n  ");
							sb.append(declFirstLine);
							sb.append("\ndes Features ");
							sb.append(toFeature.getName());
							sb.append(" zu.\n");
						} else {
							if ((state == CLASS_EXTENDS_CLASS) || (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("\nDie Klasse ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("\nDas Interface ");
							}
							sb.append(sourceHostType.name() + " des Features ");
							sb.append(fromFeature.getName());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" greift als Unterklasse der Klasse ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" greift als Implementierung des Interfaces ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" greift als Sub-Interface des Interfaces ");
							}
							sb.append(outputTargetHostType.name() + " ");
							sb.append(targetStructure);
							sb.append("\n  ");
							sb.append(declFirstLine);
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append("\nder Klasse ");
							} else if ((state == CLASS_IMPLEMENTS_INTERFACE) || (state == INTERFACE_EXTENDS_INTERFACE)) {
								sb.append("\ndes Interfaces ");
							}
							sb.append(outputTargetHostType.name() + " zu.\n");
							sb.append("Die Information, dass ");
							if ((state == CLASS_EXTENDS_CLASS) || (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("die Klasse ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("das Interface ");
							}
							sb.append(sourceHostType.name());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" eine Unterklasse der Klasse ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" eine Implementierung des Interfaces ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" ein Sub-Interface des Interfaces ");
							}
							sb.append(outputTargetHostType.name());
							sb.append(" ist, ist nur im Feature ");
							sb.append(toFeature.getName() + " vorhanden.\n");
						}
						sb.append("Das Feature ");
						sb.append(toFeature.getName());
						sb.append(" ist aber nicht in jeder ");
						sb.append("moeglichen validen Auswahl vorhanden.\n");
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
				}
			}
			/* more than one target */
		} else if (declsAndTargetHostTypes.keySet().size() > 1) {
			HashSet<Integer> toFeatureIDs = new HashSet<Integer>();	
			HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();
			for (Iterator iter = declsAndTargetHostTypes.keySet().iterator(); iter.hasNext(); ) {
				ASTNode var = (ASTNode) iter.next();
				toFeatureIDs.add(var.featureID());
				TypeDecl targetHostType = declsAndTargetHostTypes.get(var);
				String declFirstLine;
				if (isTypeAccess) {
					/* <package name (default: "(default package)")>.<type name> */
					declFirstLine = (targetHostType.packageName() != "" 
							? targetHostType.packageName() 
							: "(default package)" ) + "." + targetHostType.name();
				} else {
					String declString = var.toString();
					declFirstLine = ( declString.indexOf("\n") == -1 ? declString
							: declString.substring(0, declString.indexOf("\n")) + " ... }" );
				}
				mapDecls.put(var.featureID(), declFirstLine);
			}
			HashMap<Integer, String> outputMapDecls = new HashMap<Integer, String>();
			for (Iterator iter = outputDeclsAndTargetHostTypes.keySet().iterator(); iter.hasNext(); ) {
				ASTNode outputVar = (ASTNode) iter.next(); 
				TypeDecl outputTargetHostType = outputDeclsAndTargetHostTypes.get(outputVar);
				String declFirstLine;
				if (isTypeAccess) {
					/* <package name (default: "(default package)")>.<type name> */
					declFirstLine = (outputTargetHostType.packageName() != "" 
							? outputTargetHostType.packageName() 
							: "(default package)" ) + "." + outputTargetHostType.name();
				} else {
					String declString = outputVar.toString();
					declFirstLine = ( declString.indexOf("\n") == -1 ? declString
							: declString.substring(0, declString.indexOf("\n")) + " ... }" );
				}
				outputMapDecls.put(outputVar.featureID(), declFirstLine);
			}
			Feature fromFeature = listFeatures.get(fromFeatureID);
			/* list of set of target features */
			ArrayList<Set<Feature>> toFeaturesList = new ArrayList<Set<Feature>>();
			for (int toFeatureID : toFeatureIDs) {
				Feature toFeature = listFeatures.get(toFeatureID);
				HashSet<Feature> toFeatureSet = new HashSet<Feature>();
				toFeatureSet.add(toFeature);
				toFeaturesList.add(toFeatureSet);
			}
			/* for TypeAccess: list all source file names and line numbers, where a
			 * TypeAccess to a specific type takes place */
			StringBuilder sbtei = new StringBuilder();
			if (isTypeAccess) {
				TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(sourceHostType).get(targetHostTypes.iterator().next());
				for (String s : tei.getAccessSourceInfo()) {
					sbtei.append(s);
					sbtei.append("\n");
				}
				sbtei.setLength(sbtei.length() - 1);
			}
			HashSet<Feature> accessingFeature = new HashSet<Feature>();
			accessingFeature.add(fromFeature);
			try {
				/* all features optional, accessing feature set */
				if (model.mayBeMissing(accessingFeature, toFeaturesList)) {
					StringBuilder sb = new StringBuilder();
					sb.append(toFeatureIDs.size());
					sb.append(" optionale Ziele ");
					sb.append("(es kann eine valide Auswahl geben, "
							+ "in der alle diese Ziele nicht vorhanden sind):\n");
					if (state == FIRST_ROUND) {
						sb.append("Feature ");
						sb.append(fromFeature.getName());
						sb.append(" zielt ");
						sb.append(targetStructure);
						sb.append(" folgender Features:\n");
						for (int toFeatureID : mapDecls.keySet()) {				
							String decl = mapDecls.get(toFeatureID);
							sb.append(decl);
							sb.append("   :   ");
							sb.append(listFeatures.get(toFeatureID).getName());					
							sb.append("\n");
						}
					} else {
						if ((state == CLASS_EXTENDS_CLASS) || (state == CLASS_IMPLEMENTS_INTERFACE)) {
							sb.append("Die Klasse ");
						} else if (state == INTERFACE_EXTENDS_INTERFACE) {
							sb.append("Das Interface ");
						}
						sb.append(sourceHostType.name() + " des Features ");
						sb.append(fromFeature.getName());
						sb.append(" greift:\n");
						for (int toFeatureID : mapDecls.keySet()) {
							sb.append("- im Feature ");
							sb.append(listFeatures.get(toFeatureID).getName());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" als Unterklasse der Klasse ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" als Implementierung des Interfaces ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" als Sub-Interface des Interfaces ");
							}
							sb.append(mapDecls.get(toFeatureID));						
							sb.append(" " + targetStructure + "\n     ");
							sb.append(outputMapDecls.get(outputMapDecls.keySet().iterator().next()));
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append("\n   der Klasse ");
							} else if ((state == CLASS_IMPLEMENTS_INTERFACE) || (state == INTERFACE_EXTENDS_INTERFACE)) {
								sb.append("\n   des Interfaces ");
							}
							sb.append(mapDecls.get(toFeatureID) + " zu.\n");
						}
						sb.append("Es kann eine valide Auswahl geben, in der die Features ");
						int i = mapDecls.keySet().size();
						int j = 1;
						for (int toFeatureID : mapDecls.keySet()) {
							sb.append(listFeatures.get(toFeatureID).getName());
							if ((j + 1) < i) {
								sb.append(", ");
							} else if ((j + 1) == i) {
								sb.append(" und ");
							}
							j++;
						}
						sb.append(" alle nicht vorhanden sind.");
					}
					if (isTypeAccess) {
						typeError(sbtei.toString(), sb.toString());
					} else {
						error(sb.toString());
					}
				}
			} catch (TimeoutException e) {
				e.printStackTrace();
			}
		}
		if (!(secondRoundDone)) {
			/* second Round */

			/*
			 * bekannt: - eindeutiges Ziel (d.h. eine toFeatureID), d.h. nur eine
			 * Implementierung des Typs, im dem sich das Ziel befindet - Quell- und
			 * Ziel-Feature sind beide vorhanden - Quell- und Ziel-Feature sind
			 * unterschiedlich
			 */
			/*
			 * in jeweiliger Liste (extends, implements, throws) herausfinden, in
			 * welchem Feature Information fehlt (unter der Bedingung, dass in den
			 * anderen Features keine widerspruechliche Information vorhanden ist)
			 * maybe- oder never-Beziehung dieser Features zu/m informations-
			 * tragenden Feature(s) herausfinden -> Fehlermeldung, wenn die
			 * Information nicht in allen validen Produkten vorhanden sein kann (wenn
			 * nicht mindestens ein informationstragendes Feature in always-Beziehung
			 * zu mindestens einem Feature ohne diese Information steht) - extends
			 * (fuer Klassen und Interfaces) - implements (nur fuer Klassen) qualified
			 * name, gleichbenannte Klassen in verschiedenen Verzeichnissen? ermittle
			 * die Liste der Features, die an dieser Klasse beteiligt sind:
			 * (alternativ: mittels SPLStructure getRoleGroups)
			 */
			/*
			 * ansonsten: teste, ob extends-, implements- oder throws- Information
			 * nicht in dieser Klasse des Quellfeatures, dafuer aber nur in dieser
			 * Klasse eines Zielfeatures steht, das mit dieser Klasse des
			 * Quellfeatures in maybe-, never-, bzw. bei mehreren Ziele in
			 * mayBeMissing-Beziehung steht
			 */

			/* access from a class: check extends and implements */
			if (sourceHostType instanceof ClassDecl) {
				ClassDecl sc = (ClassDecl) sourceHostType;
				/* get all features of this class */
				HashSet<Integer> allFeatures = new HashSet<Integer>();
				for (BodyDecl bd : sc.getBodyDecls()) {
					allFeatures.add(bd.featureID());
				}
				for (TypeDecl targetHostType : targetHostTypes) {
					/* access to a class */
					if (targetHostType instanceof ClassDecl) {
						/* get all features with extends info of this targetHostType */
						HashSet<Access> accesses = new HashSet<Access>();
						if (!(sc.getPreservedSuperClassAccess().isEmpty())) {
							for (Access ac : sc.getPreservedSuperClassAccess()) {
								if (ac.type().equals(targetHostType)) {
									/* remember featureID of this feature */
									accesses.add(ac);
								}
							}
						}
						if (sc.hasSuperClassAccess()) {
							if (sc.getSuperClassAccess().type().equals(targetHostType)) {
								/* remember featureID of this feature */
								accesses.add(sc.getSuperClassAccess());
							}
						}
						/* if there is extends info of this targetHostType */
						if (!(accesses.isEmpty())) {
							HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
							for (Access ac : accesses) {
								featuresWithExtendInfo.add(ac.featureID());
							}
							/* is the extends info of this targetHostType missing
							 * in this fromFeature? */
							if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
								/* error only if internal access */
								if (isUndottedAccess) {
									HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
									for (Access ac : accesses) {
										accessesAndTargetHostTypes.put(ac, ac.hostType());
									}
									/* check for SPL errors */
									addSplErrors(fromFeatureID, accessesAndTargetHostTypes,
											targetStructure, false,
											sourceHostType, true, CLASS_EXTENDS_CLASS, outputDeclsAndTargetHostTypes, isUndottedAccess);
								}
							}
						}
					}
					/* access to interface */
					if (targetHostType instanceof InterfaceDecl) {
						/* get all features with implements info of this targetHostType */
						HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
						if (sc.getNumImplements() != 0) {
							for (Access ac : sc.getImplementsList()) {
								if (ac.type().equals(targetHostType)) {
									accessesAndTargetHostTypes.put(ac, ac.hostType());
								}
							}
						}
						/* if there are features that implement the targetHostType */
						if (!(accessesAndTargetHostTypes.keySet().isEmpty())) {
							HashSet<Integer> featuresWithImplementInfo = new HashSet<Integer>();
							for (ASTNode ac : accessesAndTargetHostTypes.keySet()) {
								featuresWithImplementInfo.add(ac.featureID());
							}
							/* is the implements info missing in this fromFeature? */
							if (!(featuresWithImplementInfo.contains(fromFeatureID))) {
								/* error only if internal access */
								if (isUndottedAccess) {
									/* check for SPL errors */
									addSplErrors(fromFeatureID, accessesAndTargetHostTypes,
											targetStructure, false,
											sourceHostType, true, CLASS_IMPLEMENTS_INTERFACE, outputDeclsAndTargetHostTypes, isUndottedAccess);
								}
							}
						}
					}
				}
			}
			/* access from an interface: check extends */
			if (sourceHostType instanceof InterfaceDecl) {
				for (TypeDecl targetHostType : targetHostTypes) {
					if (targetHostType instanceof InterfaceDecl) {
						InterfaceDecl si = (InterfaceDecl) sourceHostType;
						/* get all features of this interface */
						HashSet<Integer> allFeatures = new HashSet<Integer>();
						for (BodyDecl bd : si.getBodyDecls()) {
							allFeatures.add(bd.featureID());
						}
						/* get all feature with extends info of this targetHostType */
						HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
						if (si.getNumSuperInterfaceId() != 0) {
							for (Access ac : si.getSuperInterfaceIdList()) {
								if (ac.type().equals(targetHostType)) {
									/* remember featureID of this feature */
									accessesAndTargetHostTypes.put(ac, ac.hostType());
								}
							}
						}
						/* if there is extends info of this targetHostType */
						if (!(accessesAndTargetHostTypes.keySet().isEmpty())) {
							HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
							for (ASTNode ac : accessesAndTargetHostTypes.keySet()) {
								featuresWithExtendInfo.add(ac.featureID());
							}
							/* is the extends info of this targetHostType missing
							 * in this fromFeature? */
							if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
								/* error only if internal access */
								if (isUndottedAccess) {
									/* check for SPL errors */
									addSplErrors(fromFeatureID, accessesAndTargetHostTypes,
											targetStructure, false,
											sourceHostType, true, INTERFACE_EXTENDS_INTERFACE, outputDeclsAndTargetHostTypes, isUndottedAccess);
								}
							}
						}
					}
				}
			}
		}
	}

	public void ASTNode.splTypeCheck() { }

	public void VarAccess.splTypeCheck() {
		/* is the VarAccess a FieldAccess? */
		if (isFieldAccess()) {
			HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
			for (Iterator iter = decls().iterator(); iter.hasNext(); ) {
				BodyDecl decl = (BodyDecl) iter.next();
				declsAndTargetHostTypes.put(decl, decl.hostType());
			}
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, "auf das Feld", false,
					hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, !(hasPrevExpr()));
		}
	}

	public void MethodAccess.splTypeCheck() {
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		/* original-check: if the target method is named "original",
		 * then in this type (in another feature) 
		 * there should be a method with the same signature as the method where
		 * this access comes from */
		if (name().equals("original")) {
			/* get context, i.e. method signature of the method 
			 * where the access comes from */
			String context = ((MethodDecl) enclosingBodyDecl()).signature();
			/* get all methods with the same signature in this type 
			 * that are in another feature */
			for (BodyDecl bd : hostType().getBodyDecls()) {
				if (bd instanceof MethodDecl) {
					MethodDecl md = (MethodDecl) bd;
					if (md.signature().equals(context) && (md.featureID() != featureID())) {
						declsAndTargetHostTypes.put(md, md.hostType());
					}
				}
			}
			StringBuffer s = new StringBuffer();
			s.append("mittels des original-Aufrufs\n  ");
			s.append(name());
			s.append("(");
			for (int i = 0; i < getNumArg(); i++) {
				if (i != 0) { s.append(", "); }
				s.append(getArg(i).type().typeName());
			}
			s.append(")");
			s.append(" in der Methode " + context + " des Typs " + methodHost());
			s.append(" auf die Methode");
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, s.toString(), false,
					hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, !(hasPrevExpr()));
		} else {
			/* get all methods with the same signature as the needed method
			 * in this type */
			for (BodyDecl bd : decl().hostType().getBodyDecls()) {
				if (bd instanceof MethodDecl) {
					if (((MethodDecl) bd).signature().equals(decl().signature())) {
						declsAndTargetHostTypes.put(bd, bd.hostType());
					}
				}
			}
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, "auf die Methode",
					false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, !(hasPrevExpr()));
		}
	}

	public void TypeAccess.splTypeCheck() {
		/* collect all TypeAccesses: source feature, type, decl(s), source file(s),
		 * line number(s) */
		int fromFeatureID = featureID();
		/* ignore importDecl */
		if (isRaw()) {
			/* do not collect default types */
			if (!(fromFeatureID == -1) && !(decl().featureID() == -1) && !(hostType().featureID() == -1) && !(decl().hostType().featureID() == -1)) {
				HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> typesAndInfo = typeAccesses.get(fromFeatureID);
				if (typesAndInfo == null) {
					typesAndInfo = new HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>();
				}
				HashMap<TypeDecl, TypeErrorInfo> innerTypeAndInfo = typesAndInfo.get(hostType());
				if (innerTypeAndInfo == null) {
					innerTypeAndInfo = new HashMap<TypeDecl, TypeErrorInfo>();
				}
				/* find all constructors of this type to get sure that the type is
				 * reachable, but this is not enough: also get sure that the right
				 * constructor is reachable --> ClassInstanceExpr.splTypeCheck() */
				HashSet<ConstructorDecl> listDecls = new HashSet<ConstructorDecl>();
				for (BodyDecl bd : decl().hostType().getBodyDecls()) {
					if (bd instanceof ConstructorDecl) {
						listDecls.add((ConstructorDecl) bd);
					}
				}
				TypeErrorInfo tei = innerTypeAndInfo.get(decl().hostType());
				if (tei == null) {
					tei = new TypeErrorInfo(new SimpleSet.SimpleSetImpl(listDecls), new HashSet<String>(), !(hasPrevExpr()));
				} else {
					for (Iterator iter = tei.getDecls().iterator(); iter.hasNext(); ) {
						listDecls.add((ConstructorDecl) iter.next());
					}
					tei.setDecls(new SimpleSet.SimpleSetImpl(listDecls));
				}
				/* remember source file and line number of type access */
				tei.getAccessSourceInfo().add(sourceFile() + ":" + lineNumber());
				innerTypeAndInfo.put(decl().hostType(), tei);
				typesAndInfo.put(hostType(), innerTypeAndInfo);
				typeAccesses.put(fromFeatureID, typesAndInfo);
			}
		}
	}

	public void ClassInstanceExpr.splTypeCheck() {
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		/* get all constructors with the same signature in this type */
		for (BodyDecl bd : decl().hostType().getBodyDecls()) {
			if (bd instanceof ConstructorDecl) {
				if (((ConstructorDecl) bd).signature().equals(decl().signature())) {
					declsAndTargetHostTypes.put((ConstructorDecl) bd, decl().hostType());
				}
			}
		}
		/* check for SPL errors */
		addSplErrors(featureID(), declsAndTargetHostTypes, "auf den Konstruktor",
				false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, !(hasPrevExpr()));
	}
}