/* Extended Type Check
 * 2013-01-07
 * 
 * IMPORTANT: 
 * add jar de.ovgu.featureide.fm.core...jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fuji's build-path
 * 
 * for tests (TestSuite.java):
 * add org.eclipse.equinox.common...jar (FM-Test 03)
 * add jakarta.jar (FM-Test 03)
 * add guidsl.jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fujis's build-path
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

import fuji.TypeErrorInfo;

aspect ExtendedTypeCheck {

	/* copied from ErrorCheck.jrag and modified: added "spl" or "Spl" 
	 * in front of method names or in method names
	 * added: FeatureModel in ASTNode
	 * TODO: get sure, that the featureModel is properly initiated.
	 */

	/* */
	public void ASTNode.collectSplErrors() {
		splTypeCheck();
		for(int i = 0; i < getNumChild(); i++) {
			getChild(i).collectSplErrors();
		}
	}

	/* */
	public void Program.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
	}

	/* */
	public void Program.splErrorCheck(FeatureModel model, Collection collection, Collection warn) {	
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
				warn.addAll(cu.warnings);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
		warn.addAll(warnings);
	}

	/* */
	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		collectSplErrors();
		collection.addAll(errors);
	}

	/* */
	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection err, Collection warn) {		
		setFeatureModel(model);
		collectSplErrors();
		err.addAll(errors);
		warn.addAll(warnings);
	}

	/* */
	public boolean Program.splErrorCheck(FeatureModel model) {		
		Collection collection = new LinkedList();
		splErrorCheck(model, collection);
		if(collection.isEmpty()) {
			return false;
		}
		System.out.println("SPL Errors:");
		for(Iterator iter = collection.iterator(); iter.hasNext(); ) {
			String s = (String)iter.next();
			System.out.println(s);
		}
		return true;
	}

	/* /copy_&_modify */
	
	/* --- */

	/* the feature model */
	protected static FeatureModel ASTNode.featureModel;

	/* get the feature model */
	public FeatureModel ASTNode.getFeatureModel() {
		return featureModel;
	}

	/* set the feature model */
	public void ASTNode.setFeatureModel(FeatureModel model) {	
		featureModel = model;
	}
	
	/* (fromFeature ALWAYS toFeature) due to feature model */
	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	/* (fromFeature NEVER toFeature) due to feature model */
	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	/* (fromFeature MAYBE toFeature) due to feature model */
	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}
	
	/* for addSplError: 
	 * secondRound: relation of sourceHostType and targetHostType */
	protected static final int ASTNode.FIRST_ROUND = 0;
	protected static final int ASTNode.CLASS_EXTENDS_CLASS = 1;
	protected static final int ASTNode.CLASS_IMPLEMENTS_INTERFACE = 2;
	protected static final int ASTNode.INTERFACE_EXTENDS_INTERFACE = 3;
	
	/* */
	public void ASTNode.addSplErrors(int fromFeatureID,
			HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes,
			String targetStructure, boolean isTypeAccess, TypeDecl sourceHostType,
			boolean secondRoundDone, int state,
			HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes,
			boolean isUndottedAccess, TypeDecl narrowType, TypeDecl accessingType) {
		/* get the feature model */
		FeatureModel model = getFeatureModel();
		/* get dependencies from feature model */
		FeatureDependencies dep = new FeatureDependencies(model);
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(model.getConcreteFeatures());
		/* get targetHostTypes */
		HashSet<TypeDecl> targetHostTypes = new HashSet<TypeDecl>();
		targetHostTypes.addAll(declsAndTargetHostTypes.values());
		/* just one target (i.e. one decl) */
		if (declsAndTargetHostTypes.keySet().size() == 1) {
			/* get this decl */
			ASTNode decl = declsAndTargetHostTypes.keySet().iterator().next();
			/* get featureID of target */
			int toFeatureID = decl.featureID();
			/* get host type of target */
			TypeDecl targetHostType = declsAndTargetHostTypes.get(decl);
			/* OUTPUT */
			ASTNode outputDecl = outputDeclsAndTargetHostTypes.keySet().iterator()
					.next();
			String outputDeclString = outputDecl.toString();
			if (outputDecl instanceof ConstructorDecl) {
				ConstructorDecl cd = (ConstructorDecl) outputDecl;
				/* we have to build the output for a default constructor manually,
				 * because a default constructor is not pretty printed by
				 * JastAddJ */
				if (cd.isDefaultConstructor()) {
					StringBuffer s = new StringBuffer();
					cd.getModifiers().toString(s);
					outputDeclString = s.toString() + cd.name() + "()";
				}
			}
			TypeDecl outputTargetHostType = outputDeclsAndTargetHostTypes
					.get(outputDecl);
			String declFirstLine;
			if (isTypeAccess) {
				/* <package name (default:"(default package)")>.<type name> */
				declFirstLine = (targetHostType.packageName() != "" ? targetHostType
						.packageName() : "(default package)") + "." + targetHostType.name();
			} else {
				declFirstLine = (outputDeclString.indexOf("\n") == -1 ? outputDeclString
						: outputDeclString.substring(0, outputDeclString.indexOf("\n"))
						+ " ... }");
			}
			/* /OUTPUT */
			/* both features present? */
			if ((fromFeatureID != -1) && (toFeatureID != -1)) {
				/* different features? */
				if (fromFeatureID != toFeatureID) {
					Feature fromFeature = listFeatures.get(fromFeatureID);
					Feature toFeature = listFeatures.get(toFeatureID);
					/* fromFeature and toFeature cannot both occur in a valid product
					 * never-dep -> error */
					boolean never = never(dep, fromFeature, toFeature);
					/* toFeature can, but doesn't have to occur in a valid product
					 * maybe-dep -> error */
					boolean maybe = maybe(dep, fromFeature, toFeature);
					/* OUTPUT */
					StringBuilder sbtei = new StringBuilder();
					/*
					 * for TypeAccess: list all source file names and line numbers, where
					 * a TypeAccess to a specific type takes place
					 */
					if (isTypeAccess) {
						TypeErrorInfo tei = typeAccesses.get(fromFeatureID)
								.get(sourceHostType).get(targetHostType);
						for (String s : tei.getAccessSourceInfo()) {
							sbtei.append(s);
							sbtei.append("\n");
						}
						/* remove last "\n" */
						sbtei.setLength(sbtei.length() - 1);
					}					
					StringBuilder sb = new StringBuilder();				
					if (never) {		
						sb.append("NEVER dependency:");
					}	else if (maybe) {									
						sb.append("MAYBE dependency:");
					}	
					if (never || maybe) {
						if (state == FIRST_ROUND) {
							sb.append("\nFeature ");
							sb.append(fromFeature.getName());
							sb.append(" accesses ");
							sb.append(targetStructure);
							sb.append("\n  ");
							sb.append(declFirstLine);
							sb.append("\nof feature ");
							sb.append(toFeature.getName());
							sb.append(".\n");
						} else {
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("\nClass ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("\nInterface ");
							}
							sb.append(sourceHostType.name() + " of feature ");
							sb.append(toFeature.getName());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" (transitively) extends class ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" (transitively) implements interface ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" (transitively) extends interface ");
							}
							sb.append(outputTargetHostType.name() + ". ");
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("Class ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("Interface ");
							}
							sb.append(accessingType.name() + " of feature ");
							sb.append(fromFeature.getName());
							sb.append(" accesses ");
							if (isTypeAccess) {
								if (state == CLASS_EXTENDS_CLASS) {
									sb.append("the instance");
								} else if ((state == CLASS_IMPLEMENTS_INTERFACE)
										|| (state == INTERFACE_EXTENDS_INTERFACE)) {
									sb.append("the implementation");
								}
							} else {
								sb.append(targetStructure);
							}
							sb.append("\n  ");
							sb.append(declFirstLine);
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append("\nof class ");
							} else if ((state == CLASS_IMPLEMENTS_INTERFACE)
									|| (state == INTERFACE_EXTENDS_INTERFACE)) {
								sb.append("\nof interface ");
							}
							sb.append(outputTargetHostType.name() + ".\n");
							sb.append("The information that ");
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("class ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("interface ");
							}
							sb.append(sourceHostType.name());
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append(" (transitively) extends class ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append(" (transitively) implements interface ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append(" (transitively) extends interface ");
							}
							sb.append(outputTargetHostType.name());
							sb.append(" is only present in feature ");
							sb.append(toFeature.getName() + ".\n");
						}
					}			
					if (never) {
						sb.append("Features ");
						sb.append(fromFeature.getName());
						sb.append(" and ");
						sb.append(toFeature.getName());
						sb.append(" cannot both be present in a valid selection.\n");
					} else if (maybe) {
						sb.append("Feature ");
						sb.append(toFeature.getName());
						sb.append(" is not present in every valid selection.\n");
					}
					if (never || maybe) {
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
					/* /OUTPUT */
				}
			}
			/* more than one target */
		} else if (declsAndTargetHostTypes.keySet().size() > 1) {
			HashSet<Integer> toFeatureIDs = new HashSet<Integer>();
			HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();
			/* for every target */
			for (Iterator iter = declsAndTargetHostTypes.keySet().iterator(); iter
					.hasNext();) {
				/* get target */
				ASTNode var = (ASTNode) iter.next();
				/* add its featureID */
				toFeatureIDs.add(var.featureID());
				TypeDecl targetHostType = declsAndTargetHostTypes.get(var);
				/* OUTPUT */
				String declFirstLine;
				if (isTypeAccess) {
					/* <package name (default: "(default package)")>.<type name> */
					declFirstLine = (targetHostType.packageName() != "" ? targetHostType
							.packageName() : "(default package)") + "." + targetHostType.name();
				} else {
					String declString = var.toString();
					if (var instanceof ConstructorDecl) {
						ConstructorDecl cd = (ConstructorDecl) var;
						/* we have to build the output for a default constructor manually */
						if (cd.isDefaultConstructor()) {
							StringBuffer s = new StringBuffer();
							cd.getModifiers().toString(s);
							declString = s.toString() + cd.name() + "()";
						}
					}
					declFirstLine = (declString.indexOf("\n") == -1 ? declString
							: declString.substring(0, declString.indexOf("\n")) + " ... }");
				}
				mapDecls.put(var.featureID(), declFirstLine);
			}
			HashMap<Integer, String> outputMapDecls = new HashMap<Integer, String>();
			/* do the same for every output target */
			for (Iterator iter = outputDeclsAndTargetHostTypes.keySet().iterator(); iter
					.hasNext();) {
				/* get output target */
				ASTNode outputVar = (ASTNode) iter.next();
				TypeDecl outputTargetHostType = outputDeclsAndTargetHostTypes
						.get(outputVar);
				String declFirstLine;
				if (isTypeAccess) {
					/* <package name (default: "(default package)")>.<type name> */
					declFirstLine = (outputTargetHostType.packageName() != "" ? outputTargetHostType
							.packageName() : "(default package)")
							+ "." + outputTargetHostType.name();
				} else {
					String declString = outputVar.toString();
					if (outputVar instanceof ConstructorDecl) {
						ConstructorDecl cd = (ConstructorDecl) outputVar;
						/* we have to build the output for a default constructor manually */
						if (cd.isDefaultConstructor()) {
							StringBuffer sb = new StringBuffer();
							cd.getModifiers().toString(sb);
							declString = sb.toString() + cd.name() + "()";
						}
					}
					declFirstLine = (declString.indexOf("\n") == -1 ? declString
							: declString.substring(0, declString.indexOf("\n")) + " ... }");
				}
				outputMapDecls.put(outputVar.featureID(), declFirstLine);
				/* /OUTPUT */
			}
			/* source feature exists */
			if (fromFeatureID != -1) {
				Feature fromFeature = listFeatures.get(fromFeatureID);
				/* list of set of target features */
				ArrayList<Set<Feature>> toFeaturesList = new ArrayList<Set<Feature>>();
				for (int toFeatureID : toFeatureIDs) {
					/* target feature exists */
					if (toFeatureID != -1) {
						Feature toFeature = listFeatures.get(toFeatureID);
						HashSet<Feature> toFeatureSet = new HashSet<Feature>();
						toFeatureSet.add(toFeature);
						toFeaturesList.add(toFeatureSet);
					}
				}
				HashSet<Feature> accessingFeature = new HashSet<Feature>();
				accessingFeature.add(fromFeature);
				try {
					/* all features optional, accessing feature selected */
					boolean mayBeMissing = model.mayBeMissing(accessingFeature, toFeaturesList);
					/* OUTPUT */
					/*
					 * for TypeAccess: list all source file names and line numbers, where a
					 * TypeAccess to a specific type takes place
					 */
					StringBuilder sbtei = new StringBuilder();
					if (isTypeAccess) {
						TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(sourceHostType)
								.get(targetHostTypes.iterator().next());
						for (String s : tei.getAccessSourceInfo()) {
							sbtei.append(s);
							sbtei.append("\n");
						}
						/* remove last "\n" */
						sbtei.setLength(sbtei.length() - 1);
					}			
					if (mayBeMissing) {
						StringBuilder sb = new StringBuilder();
						sb.append(toFeatureIDs.size());
						sb.append(" optional targets ");
						sb.append("(there may be a valid selection ");
						sb.append("where none of these targets is present):\n");
						if (state == FIRST_ROUND) {
							sb.append("Feature ");
							sb.append(fromFeature.getName());
							sb.append(" accesses:\n");
							for (int toFeatureID : mapDecls.keySet()) {
								if (toFeatureID != -1) {
									sb.append("- " + targetStructure);
									String decl = mapDecls.get(toFeatureID);
									sb.append("\n    ");
									sb.append(decl);
									sb.append("\n  of feature ");
									sb.append(listFeatures.get(toFeatureID).getName());
									sb.append("\n");
								}
							}
						} else {
							if ((state == CLASS_EXTENDS_CLASS)
									|| (state == CLASS_IMPLEMENTS_INTERFACE)) {
								sb.append("Class ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("Interface ");
							}
							sb.append(sourceHostType.name() + " of feature ");
							sb.append(fromFeature.getName());
							sb.append(" accesses:\n");
							for (int toFeatureID : mapDecls.keySet()) {
								if (toFeatureID != -1) {
									sb.append("- in feature ");
									sb.append(listFeatures.get(toFeatureID).getName());
									if (state == CLASS_EXTENDS_CLASS) {
										sb.append(" as subclass of class ");
									} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
										sb.append(" as implementation of interface ");
									} else if (state == INTERFACE_EXTENDS_INTERFACE) {
										sb.append(" as subinterface of interface ");
									}
									sb.append(mapDecls.get(toFeatureID));
									sb.append(" " + targetStructure + "\n     ");
									sb.append(outputMapDecls.get(outputMapDecls.keySet().iterator()
											.next()));
									if (state == CLASS_EXTENDS_CLASS) {
										sb.append("\n   of class ");
									} else if ((state == CLASS_IMPLEMENTS_INTERFACE)
											|| (state == INTERFACE_EXTENDS_INTERFACE)) {
										sb.append("\n   of interface ");
									}
									sb.append(mapDecls.get(toFeatureID) + ".\n");
								}
							}
							sb.append("There may be a valid selection where none of the features ");
							int i = mapDecls.keySet().size();
							int j = 1;
							for (int toFeatureID : mapDecls.keySet()) {
								if (toFeatureID != -1) {
									sb.append(listFeatures.get(toFeatureID).getName());
									if ((j + 1) < i) {
										sb.append(", ");
									} else if ((j + 1) == i) {
										sb.append(" and ");
									}
									j++;
								}
							}
							sb.append(" is present.\n");
							sb.append("So it may be that the information that ");
							if (state == CLASS_EXTENDS_CLASS) {
								sb.append("class " + sourceHostType.name()
										+ " (transitively) extends the class(es) above ");
							} else if (state == CLASS_IMPLEMENTS_INTERFACE) {
								sb.append("class " + sourceHostType.name()
										+ " (transitively) implements the interface(s) above ");
							} else if (state == INTERFACE_EXTENDS_INTERFACE) {
								sb.append("interface "
										+ sourceHostType.name()
										+ " (transitively) extends the interface(s) above ");
							}
							sb.append("is not present at all.\n");
						}
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
					/* /OUTPUT */
				} catch (TimeoutException e) {
					e.printStackTrace();
				}
			}
		}
		if (!(secondRoundDone)) {
			/* second Round */
			/* get all feature IDs*/
			HashSet<Integer> toFeatureIDs = new HashSet<Integer>();
			for (Iterator iter = declsAndTargetHostTypes.keySet().iterator(); iter
					.hasNext();) {
				ASTNode var = (ASTNode) iter.next();
				toFeatureIDs.add(var.featureID());
			}
			/* external access: move starting point of checks to narrow type */
			if (!(isUndottedAccess)) {
				/* no more interest in accessing host type, get narrow type */
				sourceHostType = narrowType;
			}
			/* for all targets */
			for (TypeDecl top : targetHostTypes) {
				/* fromFeature present and no access to a standard type */
				if (fromFeatureID != -1 && !(toFeatureIDs.contains(-1))) {
					/* access to different host type */
					if (!(sourceHostType.equals(top))) {
						/* get paths in type hierarchy from source to target */
						HashMap<TypeDecl, HashSet<TypeDecl>> paths = getTypeHierarchyPaths(
								sourceHostType, top);
						/* there is at least one subtype relation */
						if (!(paths.isEmpty())) {
							/* check for every path if the information about 
							 * the subtype relation in every step is always available */
							for (TypeDecl nextTd : paths.get(sourceHostType)) {
								/* check <paths> in type hierarchy 
								 * from <sourceHostType> (bottom) to <top> 
								 * over <nextTd> (super types of bottom) */
								splErrorCheckAccessToSuperType(sourceHostType, nextTd, top, paths, 
										fromFeatureID, targetStructure, outputDeclsAndTargetHostTypes,
										isUndottedAccess, narrowType, accessingType);
							}							
						}
					}
				}
			}
		}
	}
	
	/* */
	public void ASTNode.splErrorCheckAccessToSuperType(TypeDecl currentSourceHostType, 
  		TypeDecl td, TypeDecl top, HashMap<TypeDecl, HashSet<TypeDecl>> paths, 
  		int fromFeatureID, String targetStructure, 
  		HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes,
  		boolean isUndottedAccess, TypeDecl narrowType, TypeDecl accessingType) {
		/* get the feature model */
  	FeatureModel model = getFeatureModel();
		/* get dependencies from feature model */
		FeatureDependencies dep = new FeatureDependencies(model);
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(model.getConcreteFeatures());
		/* access from a class: check extends and implements */
		if (currentSourceHostType instanceof ClassDecl) {
			ClassDecl sc = (ClassDecl) currentSourceHostType;
			/* get all features of this class */
			HashSet<Integer> allFeatures = new HashSet<Integer>();
			for (BodyDecl bd : sc.getBodyDecls()) {
				if (bd.featureID() != -1) {
				  allFeatures.add(bd.featureID());
				}
			}
			/* access to a class */
			if (td instanceof ClassDecl) {
				/* get all features with extends info of this targetHostType */
				HashSet<Access> accesses = new HashSet<Access>();
				/* get preserved super class accesses */
				if (!(sc.getPreservedSuperClassAccess().isEmpty())) {
					for (Access ac : sc.getPreservedSuperClassAccess()) {
						if (ac.type().equals(td)) {
							accesses.add(ac);
						}
					}
				}
				/* get super class access */
				if (sc.hasSuperClassAccess()) {
					if (sc.getSuperClassAccess().type().equals(td)) {
						accesses.add(sc.getSuperClassAccess());
					}
				}
				/* if there is extends info of this targetHostType */
				if (!(accesses.isEmpty())) {
					HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
					for (Access ac : accesses) {
						featuresWithExtendInfo.add(ac.featureID());
					}
					/* if this is an internal access, i.e. field/method/type
					 * should be accessible from within this class/interface,
					 * check for missing extends information based on this
					 * feature and sourceHostType */
					if (isUndottedAccess) {
						/* is the extends info of this targetHostType missing in
						 * this fromFeature? */
						if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
							HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
							for (Access ac : accesses) {
								accessesAndTargetHostTypes.put(ac, ac.hostType());
							}
							/* check for SPL errors */
							addSplErrors(fromFeatureID,
									accessesAndTargetHostTypes, targetStructure,
									false, currentSourceHostType, true,
									CLASS_EXTENDS_CLASS,
									outputDeclsAndTargetHostTypes, isUndottedAccess,
									currentSourceHostType, accessingType);
						}
					} else {
						/* external access: start from all features of the
						 * needed narrow type that are in an always relation
						 * with the accessing feature (other errors are checked
						 * for in the first round). */
						HashSet<Integer> alwaysIDs = new HashSet<Integer>();
						for (int featureID : allFeatures) {
							if (always(dep, listFeatures.get(fromFeatureID),
									listFeatures.get(featureID))) {
								alwaysIDs.add(featureID);
							}
						}
						/* for all these features: check if the extends info is
						 * missing in this feature */
						for (int featureID : alwaysIDs) {
							if (!(featuresWithExtendInfo.contains(featureID))) {
								HashMap<ASTNode, TypeDecl> narrowTypeAccessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								for (Access ac : accesses) {
									narrowTypeAccessesAndTargetHostTypes.put(ac,
											ac.hostType());
								}
								/* TODO: review, better way? */
								HashMap<ASTNode, TypeDecl> nextTdAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								nextTdAndTargetHostTypes.put(outputDeclsAndTargetHostTypes.keySet().iterator().next(), td);
								/* check for SPL errors, narrow type */
								addSplErrors(featureID,
										narrowTypeAccessesAndTargetHostTypes,
										targetStructure, false, currentSourceHostType, true,
										CLASS_EXTENDS_CLASS,
										nextTdAndTargetHostTypes,
										isUndottedAccess, narrowType, accessingType);
							}
						}
					}
				}
			}
			/* access to interface */
			if (td instanceof InterfaceDecl) {
				/* get all features with implements info of this
				 * targetHostType */
				HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
				if (sc.getNumImplements() != 0) {
					for (Access ac : sc.getImplementsList()) {
						if (ac.type().equals(td)) {
							accessesAndTargetHostTypes.put(ac, ac.hostType());
						}
					}
				}
				/* if there are features that implement the targetHostType */
				if (!(accessesAndTargetHostTypes.keySet().isEmpty())) {
					HashSet<Integer> featuresWithImplementInfo = new HashSet<Integer>();
					for (ASTNode ac : accessesAndTargetHostTypes.keySet()) {
						featuresWithImplementInfo.add(ac.featureID());
					}
					/* if this is an internal access, i.e. field/method/type
					 * should be accessible from within this class/interface,
					 * check for missing implements information based on this
					 * feature and sourceHostType */
					if (isUndottedAccess) {
						/* is the implements info of this targetHostType missing
						 * in this fromFeature? */
						if (!(featuresWithImplementInfo.contains(fromFeatureID))) {
							/* check for SPL errors */
							addSplErrors(fromFeatureID,
									accessesAndTargetHostTypes, targetStructure,
									false, currentSourceHostType, true,
									CLASS_IMPLEMENTS_INTERFACE,
									outputDeclsAndTargetHostTypes, isUndottedAccess,
									currentSourceHostType, accessingType);
						}
					} else {
						/* external access: start from all features of the
						 * needed narrow type that are in an always relation
						 * with the accessing feature (other errors are checked
						 * for in the first round). */
						HashSet<Integer> alwaysIDs = new HashSet<Integer>();
						for (int featureID : allFeatures) {
							if (always(dep, listFeatures.get(fromFeatureID),
									listFeatures.get(featureID))) {
								alwaysIDs.add(featureID);
							}
						}
						/* for all these features: check if the implements info
						 * is missing in this feature */
						for (int featureID : alwaysIDs) {
							if (!(featuresWithImplementInfo.contains(featureID))) {
								/* TODO: review, better way? */
								HashMap<ASTNode, TypeDecl> nextTdAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								nextTdAndTargetHostTypes.put(outputDeclsAndTargetHostTypes.keySet().iterator().next(), td);
								/* check for SPL errors, narrow type */
								addSplErrors(featureID,
										accessesAndTargetHostTypes, targetStructure,
										false, currentSourceHostType, true,
										CLASS_IMPLEMENTS_INTERFACE,
										nextTdAndTargetHostTypes,
										isUndottedAccess, narrowType, accessingType);
							}
						}
					}
				}
			}
		}
		/* access from an interface: check extends */
		if (currentSourceHostType instanceof InterfaceDecl) {
			if (td instanceof InterfaceDecl) {
				InterfaceDecl si = (InterfaceDecl) currentSourceHostType;
				/* get all features of this interface */
				HashSet<Integer> allFeatures = new HashSet<Integer>();
				for (BodyDecl bd : si.getBodyDecls()) {
					if (bd.featureID() != -1) {
					  allFeatures.add(bd.featureID());
					}
				}
				/* get all feature with extends info of this targetHostType */
				HashMap<ASTNode, TypeDecl> accessesAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
				if (si.getNumSuperInterfaceId() != 0) {
					for (Access ac : si.getSuperInterfaceIdList()) {
						if (ac.type().equals(td)) {
							/* remember featureID of this feature */
							accessesAndTargetHostTypes.put(ac, ac.hostType());
						}
					}
				}
				/* if there is extends info of this targetHostType */
				if (!(accessesAndTargetHostTypes.keySet().isEmpty())) {
					HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
					for (ASTNode ac : accessesAndTargetHostTypes.keySet()) {
						featuresWithExtendInfo.add(ac.featureID());
					}
					/* if this is an internal access, i.e. field/method/type
					 * should be accessible from within this class/interface,
					 * check for missing extends information based on this
					 * feature and sourceHostType */
					if (isUndottedAccess) {
						/* is the extends info of this targetHostType missing in
						 * this fromFeature? */
						if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
							/* check for SPL errors */
							addSplErrors(fromFeatureID,
									accessesAndTargetHostTypes, targetStructure,
									false, currentSourceHostType, true,
									INTERFACE_EXTENDS_INTERFACE,
									outputDeclsAndTargetHostTypes, isUndottedAccess,
									currentSourceHostType, accessingType);
						}
					} else {
						/* external access: start from all features of the
						 * needed narrow type that are in an always relation
						 * with the accessing feature (other errors are checked
						 * for in the first round). */
						HashSet<Integer> alwaysIDs = new HashSet<Integer>();
						for (int featureID : allFeatures) {
							if (always(dep, listFeatures.get(fromFeatureID),
									listFeatures.get(featureID))) {
								alwaysIDs.add(featureID);
							}
						}
						/* for all these features: check if the extends info is
						 * missing in this feature */
						for (int featureID : alwaysIDs) {
							if (!(featuresWithExtendInfo.contains(featureID))) {
								/* TODO: review, better way? */
								HashMap<ASTNode, TypeDecl> nextTdAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
								nextTdAndTargetHostTypes.put(outputDeclsAndTargetHostTypes.keySet().iterator().next(), td);
								/* check for SPL errors, narrow type */
								addSplErrors(featureID,
										accessesAndTargetHostTypes, targetStructure,
										false, currentSourceHostType, true,
										INTERFACE_EXTENDS_INTERFACE,
										nextTdAndTargetHostTypes,
										isUndottedAccess, narrowType, accessingType);
							}
						}
					}
				}
			}
		}
		/* we didn't reach the top yet, go up in the type hierarchy 
		 * and look for similar errors */
		if (!(td.equals(top))) {
			/* different ways up */
			for (TypeDecl nextTd : paths.get(currentSourceHostType)) {
				/* recursive call */
				splErrorCheckAccessToSuperType(td, nextTd, top, paths, fromFeatureID, 
						targetStructure, outputDeclsAndTargetHostTypes, isUndottedAccess,
						narrowType, accessingType);
			}
		}
	}
	
	/* is this type (= bottom) in the type hierarchy beneath 
	 * another type (= top) */
	public boolean TypeDecl.isInTypeHierarchy(TypeDecl topType) {
		boolean isInTypeHierarchy = false;
		if (this.equals(topType)) {
			/* relation is reflexive, TODO necessary ? */
			isInTypeHierarchy = true;
		} else {
			HashSet<Access> accesses = new HashSet<Access>();
			if (this instanceof ClassDecl) {
				ClassDecl cd = (ClassDecl) this;
				/* get extends information */
				if (!(cd.getPreservedSuperClassAccess().isEmpty())) {
					accesses.addAll(cd.getPreservedSuperClassAccess());
				}
				if (cd.hasSuperClassAccess()) {
					accesses.add(cd.getSuperClassAccess());
				}
				/* get implements information */
				if (cd.getNumImplements() != 0) {
					for (Access ac : cd.getImplementsList()) {
						accesses.add(ac);
					}
				}
			} else if (this instanceof InterfaceDecl) {
				InterfaceDecl id = (InterfaceDecl) this;
				/* get extends information*/
				if (id.getNumSuperInterfaceId() != 0) {
					for (Access ac : id.getSuperInterfaceIdList()) {
						accesses.add(ac);
					}
				}
			}
			HashSet<TypeDecl> accessHostTypes = new HashSet<TypeDecl>();
			if (!(accesses.isEmpty())) {
				for (Access ac : accesses) {
					if (ac instanceof TypeAccess) {
						TypeAccess tac = (TypeAccess) ac;
						accessHostTypes.add(tac.decl().hostType());
					}
				}
			}
			if (!(accessHostTypes.isEmpty())) {
				if (accessHostTypes.contains(topType)) {
					/* found in this step */
					isInTypeHierarchy = true;
				} else {
					for (TypeDecl td : accessHostTypes) {
						/* recursive step */
						isInTypeHierarchy |= td.isInTypeHierarchy(topType);
					}
				}		
			}
		}
		return isInTypeHierarchy;
	}
	
	/* list the paths in the type hierarchy from bottomType to topType 
	 * returns an empty map if there are no paths, 
	 * key points to all supertypes of this type */
	public HashMap<TypeDecl, HashSet<TypeDecl>> ASTNode.getTypeHierarchyPaths(TypeDecl bottomType, TypeDecl topType) {
		HashMap<TypeDecl, HashSet<TypeDecl>> paths = new HashMap<TypeDecl, HashSet<TypeDecl>>();
		HashSet<TypeDecl> superTypes = new HashSet<TypeDecl>();
		if (bottomType.equals(topType)) {
			/* relation is reflexive, TODO: neccessary ? */
			superTypes.add(topType);
			paths.put(bottomType, superTypes);
		} else {
			HashSet<Access> accesses = new HashSet<Access>();
			if (bottomType instanceof ClassDecl) {
				ClassDecl cd = (ClassDecl) bottomType;
				/* get extends information (Class) */
				if (!(cd.getPreservedSuperClassAccess().isEmpty())) {
					accesses.addAll(cd.getPreservedSuperClassAccess());
				}
				if (cd.hasSuperClassAccess()) {
					accesses.add(cd.getSuperClassAccess());
				}
				/* get implements information (Class) */
				if (cd.getNumImplements() != 0) {
					for (Access ac : cd.getImplementsList()) {
						accesses.add(ac);
					}
				}
			} else if (bottomType instanceof InterfaceDecl) {
				InterfaceDecl ifd = (InterfaceDecl) bottomType;
				/* get extends information (Interface) */
				if (ifd.getNumSuperInterfaceId() != 0) {
					for (Access ac : ifd.getSuperInterfaceIdList()) {
						accesses.add(ac);
					}
				}
			}
			HashSet<TypeDecl> accessHostTypes = new HashSet<TypeDecl>();
			if (!(accesses.isEmpty())) {
				for (Access ac : accesses) {
					if (ac instanceof TypeAccess) {
						TypeAccess tac = (TypeAccess) ac;
						accessHostTypes.add(tac.decl().hostType());
					}
				}
			}
			if (!(accessHostTypes.isEmpty())) {
				if (accessHostTypes.contains(topType)) {
					/* direct super type */
					superTypes.add(topType);
					paths.put(bottomType, superTypes);
					/* search for other paths to topType */
					accessHostTypes.remove(topType);
				}
				boolean nextStepOK = false;
				for (TypeDecl td : accessHostTypes) {
					/* recursive step */
					HashMap<TypeDecl, HashSet<TypeDecl>> nextStep = getTypeHierarchyPaths(td, topType);
					if (!(nextStep.isEmpty())) {
						nextStepOK = true;
						paths.putAll(nextStep);
						superTypes.add(td);
					}
				}
				if (nextStepOK) {
					/* add beginning of path */
					paths.put(bottomType, superTypes);
				}		
			}
		}
		return paths;
	}
	
	/* --- */
	
	/* collect all TypeAccesses in a Map 
	 * format: 
	 * map: (fromFeatureID, map: (sourceHostType, map: (targetHostType, TypeErrorInfo)))
	 * (TypeErrorInfo decls: accesses to constructors of this type 
   * and source file name and line number of these type accesses) */
	protected static HashMap<Integer, HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>> ASTNode.typeAccesses =
	new HashMap<Integer, HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>>();

	/* for type accesses */
	protected ArrayList Program.errors = new ArrayList();

	/* for type accesses */
	protected ArrayList Program.warnings = new ArrayList();
	
	/* report a type error
	 * correct line number and file name */
	public void ASTNode.typeError(String accessSourceInfo, String msg) {
		ASTNode node = this;
		while(node != null && !(node instanceof Program))
			node = node.getParent();
		Program pr = (Program) node;
		pr.errors.add(new Problem(accessSourceInfo, msg, 
				Problem.Severity.ERROR, Problem.Kind.SEMANTIC));
	}

	/* line numbers included in fileName */
	public Problem.Problem(String fileName, String message, Severity severity, Kind kind) {
		this(fileName, message);
		this.kind = kind;
		this.severity = severity;
	}
	
	/* collect Type Errors */
	public void ASTNode.collectSplTypeErrors() {
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		listFeatures.addAll(featureModel.getConcreteFeatures());
		/* for all fromFeatureIDs that need types */
		for (int i : typeAccesses.keySet()) {
			Feature fromFeature = listFeatures.get(i);
			if (!(typeAccesses.get(i).isEmpty())) {
				HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> typesAndInfo = typeAccesses.get(i);
				if (!(typesAndInfo.keySet().isEmpty())) {
					/* for all sourceHostTypes where a type is needed in this feature */
					for (TypeDecl sourceHostType : typesAndInfo.keySet()) {
						HashMap<TypeDecl, TypeErrorInfo> innerTypeAndInfo = typesAndInfo.get(sourceHostType);
						if (!(innerTypeAndInfo.keySet().isEmpty())) {
							/* for all targetHostTypes needed by this sourceHostType in this feature */
							for (TypeDecl targetHostType : innerTypeAndInfo.keySet()) {
								/* get type accesses to contructors of the needed type */
								SimpleSet decls = innerTypeAndInfo.get(targetHostType).getDecls();
								/* wrap together type accesses and the needed type */
								HashMap<ASTNode, TypeDecl> declsAndTargetHostType = new HashMap<ASTNode, TypeDecl>();
								for (Iterator iter = decls.iterator(); iter.hasNext(); ) {
								  declsAndTargetHostType.put((ASTNode) iter.next(), targetHostType);
								}
								/* check for SPL errors */
								addSplErrors(i, declsAndTargetHostType, "the type", true, sourceHostType, false, FIRST_ROUND, declsAndTargetHostType,
										innerTypeAndInfo.get(targetHostType).isUndottedAccess(), sourceHostType, sourceHostType);
							}
						}
					}
				}
			}
		}
	}

	/* */
	public void ASTNode.splTypeCheck() { }

	/* */
	public void VarAccess.splTypeCheck() {
		/* from java.ast: VarAccess : Access ::= <ID:String>; */
		/* is the VarAccess a FieldAccess? */
		if (isFieldAccess()) {
			HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
			for (Iterator iter = decls().iterator(); iter.hasNext(); ) {
				BodyDecl decl = (BodyDecl) iter.next();
				declsAndTargetHostTypes.put(decl, decl.hostType());
			}
			TypeDecl narrowType = hostType();
			if (isQualified()) {
				Expr expr = qualifier();
				if (expr instanceof VarAccess) {
					VarAccess varAc = (VarAccess) expr;
					if (varAc.decl() instanceof VariableDeclaration) {
						VariableDeclaration vd = (VariableDeclaration) varAc.decl();
						if (vd.hasInit()) {
							narrowType = vd.getInit().type();
						} /* else: TODO */
					} else if (varAc.decl() instanceof FieldDeclaration) {
						FieldDeclaration fd = (FieldDeclaration) varAc.decl();
						if (fd.hasInit()) {
							narrowType = fd.getInit().type();
						} /* else: TODO */
					}
				} else if (expr instanceof TypeAccess) {
					TypeAccess typeAc = (TypeAccess) expr;
					narrowType = typeAc.type();
				} else if (expr instanceof ClassInstanceExpr) {
					ClassInstanceExpr cie = (ClassInstanceExpr) expr;
					narrowType = cie.type();
				} else if (expr instanceof ParExpr) {
					ParExpr parExpr = (ParExpr) expr;
					narrowType = parExpr.type();
					if (parExpr.getExpr() instanceof CastExpr) {
						CastExpr ce = (CastExpr) parExpr.getExpr();
						narrowType = ce.getExpr().type();
					}
				}
			}
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, "the field", false,
					hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
					(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
					narrowType, narrowType);
		}
	}

	/* */
	public void MethodAccess.splTypeCheck() {
		/* from java.ast: MethodAccess : Access ::= <ID:String> Arg:Expr*; */
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		/* original-check: if the target method is named "original",
		 * then in this type (in another feature) 
		 * there should be a method with the same signature as the method where
		 * this access comes from */
		if (name().equals("original")) {
			/* get context, i.e. method signature of the method 
			 * where the access comes from */
			String context = ((MethodDecl) enclosingBodyDecl()).signature();
			/* get all methods with the same signature in this type 
			 * that are in another feature */
			for (BodyDecl bd : hostType().getBodyDecls()) {
				if (bd instanceof MethodDecl) {
					MethodDecl md = (MethodDecl) bd;
					if (md.signature().equals(context) && (md.featureID() != featureID())) {
						declsAndTargetHostTypes.put(md, md.hostType());
					}
				}
			}
			StringBuffer s = new StringBuffer();
			s.append("with original-call\n    ");
			s.append(name());
			s.append("(");
			for (int i = 0; i < getNumArg(); i++) {
				if (i != 0) { s.append(", "); }
				s.append(getArg(i).type().typeName());
			}
			s.append(")");
			s.append("\n  in method\n    " + context + "\n  of type " + methodHost());
			s.append("\nmethod");
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, s.toString(), false,
					hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, !(isQualified()), hostType(), hostType());
			/* check, if types of arguments fit the method declaration 
			 * (i.e. check, if the information that the type of an argument is 
			 * a subtype of the expected parameter is always available due to 
			 * the feature model) */
			for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
				if (decl instanceof MethodDecl) {
					MethodDecl md = (MethodDecl) decl;
					for (int i = 0; i < getNumArg(); i++) {
						/* different type of argument and parameter */
						if (!((getArg(i).type()).equals((md.getParameter(i).type())))) {
							HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
							typeDeclsAndTargetHostTypes.put(md.getParameter(i).type(), md.getParameter(i).type().hostType());
							/* check for SPL errors */
			  			addSplErrors(featureID(), typeDeclsAndTargetHostTypes, "by an implicit cast from argument to parameter type", false, hostType(), 
			  					false, FIRST_ROUND, typeDeclsAndTargetHostTypes, false, getArg(i).type(), getArg(i).type());
						}
					}
				}
			}
		} else {
			/* get all methods with the same signature as the needed method
			 * in this type */
			for (BodyDecl bd : decl().hostType().getBodyDecls()) {
				if (bd instanceof MethodDecl) {
					if (((MethodDecl) bd).signature().equals(decl().signature())) {
						declsAndTargetHostTypes.put(bd, bd.hostType());
					}
				}
			}
			TypeDecl narrowType = hostType();
			if (isQualified()) {
				Expr expr = qualifier();
				if (expr instanceof VarAccess) {
					VarAccess varAc = (VarAccess) expr;
					if (varAc.decl() instanceof VariableDeclaration) {
						VariableDeclaration vd = (VariableDeclaration) varAc.decl();
						if (vd.hasInit()) {
							narrowType = vd.getInit().type();
						} /* else: TODO */
					} else if (varAc.decl() instanceof FieldDeclaration) {
						FieldDeclaration fd = (FieldDeclaration) varAc.decl();
						if (fd.hasInit()) {
							narrowType = fd.getInit().type();
						}
					}
				} else if (expr instanceof TypeAccess) {
					TypeAccess typeAc = (TypeAccess) expr;
					narrowType = typeAc.type();
				} else if (expr instanceof ClassInstanceExpr) {
					ClassInstanceExpr cie = (ClassInstanceExpr) expr;
					narrowType = cie.type();
				} else if (expr instanceof ParExpr) {
					ParExpr parExpr = (ParExpr) expr;
					narrowType = parExpr.type();
					if (parExpr.getExpr() instanceof CastExpr) {
						CastExpr ce = (CastExpr) parExpr.getExpr();
						narrowType = ce.getExpr().type();
					}
				}
			}
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, "the method",
					false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
					(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
					narrowType, narrowType);
			/* check, if types of arguments fit the method declaration 
			 * (i.e. check, if the information that the type of an argument is 
			 * a subtype of the expected parameter is always available due to 
			 * the feature model) */
			for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
				if (decl instanceof MethodDecl) {
					MethodDecl md = (MethodDecl) decl;
					for (int i = 0; i < getNumArg(); i++) {
						/* different type of argument and parameter */
						if (!((getArg(i).type()).equals((md.getParameter(i).type())))) {
							HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
							typeDeclsAndTargetHostTypes.put(md.getParameter(i).type(), md.getParameter(i).type().hostType());
							/* check for SPL errors */
			  			addSplErrors(featureID(), typeDeclsAndTargetHostTypes, "by an implicit cast from argument type to parameter type", false, hostType(), 
			  					false, FIRST_ROUND, typeDeclsAndTargetHostTypes, false, getArg(i).type(), getArg(i).type());
						}
					}
				}
			}
		}
	}

	/* */
	public void TypeAccess.splTypeCheck() {
		/* from java.ast: TypeAccess : Access ::= <Package:String> <ID:String>; */
		/* collect all TypeAccesses: source feature, type, decl(s), source file(s),
		 * line number(s) */
		int fromFeatureID = featureID();
		/* ignore importDecl */
		if (isRaw()) {
			/* do not collect default types */
			if (!(fromFeatureID == -1) && !(decl().featureID() == -1) && !(hostType().featureID() == -1) && !(decl().hostType().featureID() == -1)) {
				HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>> typesAndInfo = typeAccesses.get(fromFeatureID);
				if (typesAndInfo == null) {
					typesAndInfo = new HashMap<TypeDecl, HashMap<TypeDecl, TypeErrorInfo>>();
				}
				HashMap<TypeDecl, TypeErrorInfo> innerTypeAndInfo = typesAndInfo.get(hostType());
				if (innerTypeAndInfo == null) {
					innerTypeAndInfo = new HashMap<TypeDecl, TypeErrorInfo>();
				}
				/* find all constructors of this type to get sure that the type is
				 * reachable, but this is not enough: also get sure that the right
				 * constructor is reachable --> ClassInstanceExpr.splTypeCheck() */
				HashSet<ConstructorDecl> listDecls = new HashSet<ConstructorDecl>();
				for (BodyDecl bd : decl().hostType().getBodyDecls()) {
					if (bd instanceof ConstructorDecl) {
						listDecls.add((ConstructorDecl) bd);
					}
				}
				TypeErrorInfo tei = innerTypeAndInfo.get(decl().hostType());
				if (tei == null) {
					tei = new TypeErrorInfo(new SimpleSet.SimpleSetImpl(listDecls), new HashSet<String>(), 
							(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()));
				} else {
					for (Iterator iter = tei.getDecls().iterator(); iter.hasNext(); ) {
						listDecls.add((ConstructorDecl) iter.next());
					}
					tei.setDecls(new SimpleSet.SimpleSetImpl(listDecls));
				}
				/* remember source file and line number of type access */
				tei.getAccessSourceInfo().add(sourceFile() + ":" + lineNumber());
				innerTypeAndInfo.put(decl().hostType(), tei);
				typesAndInfo.put(hostType(), innerTypeAndInfo);
				typeAccesses.put(fromFeatureID, typesAndInfo);
			}
		}
	}

	/* */
	public void ClassInstanceExpr.splTypeCheck() {
		/* from java.ast: ClassInstanceExpr : Access ::= Access Arg:Expr* [TypeDecl]; */
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		/* get all constructors with the same signature in this type */
		for (BodyDecl bd : decl().hostType().getBodyDecls()) {
			if (bd instanceof ConstructorDecl) {
				if (((ConstructorDecl) bd).signature().equals(decl().signature())) {
					declsAndTargetHostTypes.put((ConstructorDecl) bd, decl().hostType());
				}
			}
		}
		/* check for SPL errors */
		addSplErrors(featureID(), declsAndTargetHostTypes, "the constructor",
				false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
				(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
				decl().hostType(), decl().hostType());
		/* check, if types of arguments fit the constructor declaration 
		 * (i.e. check, if the information that the type of an argument is 
		 * a subtype of the expected parameter is always available due to 
		 * the feature model) */
		for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
			if (decl instanceof ConstructorDecl) {
				ConstructorDecl cd = (ConstructorDecl) decl;
				for (int i = 0; i < getNumArg(); i++) {
					/* different type of argument and parameter */
					if (!((getArg(i).type()).equals((cd.getParameter(i).type())))) {
						HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
						typeDeclsAndTargetHostTypes.put(cd.getParameter(i).type(), cd.getParameter(i).type().hostType());
						/* check for SPL errors */
		  			addSplErrors(featureID(), typeDeclsAndTargetHostTypes, "by an implicit cast from argument type to parameter type", false, hostType(), 
		  					false, FIRST_ROUND, typeDeclsAndTargetHostTypes, false, getArg(i).type(), getArg(i).type());
					}
				}
			}
		}
	}
	
//	/* not working? */
//	public void ConstructorAccess.splTypeCheck() {
//		/* from java.ast: ConstructorAccess : Access ::= <ID:String> Arg:Expr*; */
//		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
//		System.out.println("ConstructorAccess");
//		for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
//			ConstructorDecl cd = (ConstructorDecl) iter.next();
//			declsAndTargetHostTypes.put(cd, cd.hostType());
//		}
//		/* check for SPL errors */
//		addSplErrors(featureID(), declsAndTargetHostTypes, "the constructor",
//				false, hostType(), false, FIRST_ROUND, declsAndTargetHostTypes, 
//				(!(isQualified()) || qualifier().isThisAccess() || qualifier().isSuperAccess()), 
//				decl().hostType(), decl().hostType());
//	}
	
	/* */
	public void FieldDeclaration.splTypeCheck() {
		/* from java.ast: FieldDeclaration : MemberDecl ::= Modifiers TypeAccess:Access <ID:String> [Init:Expr]; // Simplified FieldDecl */
		/* UpperType upper = new LowerType(...); [UpperType != LowerType] */
  	HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
  	HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
  	if (hasInit()) {
  		/* class instance ("new" keyword) */
  		if (getInit() instanceof ClassInstanceExpr) {
  			TypeDecl sourceType = getInit().type();
  			TypeDecl targetType = type();
  			if (!(sourceType.equals(targetType))) {
  				declsAndTargetHostTypes.put(getInit(), targetType);
  				outputDeclsAndTargetHostTypes.put(targetType, targetType);
  				/* check for SPL errors */
  				addSplErrors(featureID(), declsAndTargetHostTypes, "(by an implicit cast) the type",
  						false, hostType(), false, FIRST_ROUND, outputDeclsAndTargetHostTypes, false, sourceType, sourceType);
  			}
  		}
  	}
  }
	
	/* */
	public void VariableDeclaration.splTypeCheck() {
		/* from java.ast: VariableDeclaration : Stmt ::= Modifiers TypeAccess:Access <ID:String> [Init:Expr]; // Simplified VarDeclStmt */
		/* UpperType upper = new LowerType(...); [UpperType != LowerType] */
  	HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
  	HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
  	if (hasInit()) {
  		/* class instance ("new" keyword) */
  		if (getInit() instanceof ClassInstanceExpr) {
  			TypeDecl sourceType = getInit().type();
  			TypeDecl targetType = type();
  			if (!(sourceType.equals(targetType))) {
  				declsAndTargetHostTypes.put(getInit(), targetType);
  				outputDeclsAndTargetHostTypes.put(targetType, targetType);
  				/* check for SPL errors */
  				addSplErrors(featureID(), declsAndTargetHostTypes, "(by an implicit cast) the type",
  						false, hostType(), false, FIRST_ROUND, outputDeclsAndTargetHostTypes, false, sourceType, sourceType);
  			}
  		}
  	}
  }
	
	/* */
	public void AssignSimpleExpr.splTypeCheck() {
		/* from java.ast: AssignSimpleExpr : AssignExpr ; */
		/* report a type error, if a new class instance is implicitly casted to a
		 * supertype in this assignment and the information 
		 * of this subtype relation is only available in features that 
		 * are all optional or mutual exclusive to the selected feature 
		 * (so there could be a valid feature selection where the information 
		 * of this subtype relation is not present) */
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		HashMap<ASTNode, TypeDecl> outputDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		/* class instance ("new" keyword) */
		if (getSource() instanceof ClassInstanceExpr) {
			/* from java.ast: 
			 * ClassInstanceExpr : Access ::= Access Arg:Expr* [TypeDecl]; 
			 * abstract AssignExpr : Expr ::= Dest:Expr Source:Expr; */
			TypeDecl sourceType = getSource().type(); /* right hand side of "=" */
			TypeDecl targetType = getDest().type();   /* left  hand side of "=" */
			/* implicit cast */
			if (!(sourceType.equals(targetType))) {
				declsAndTargetHostTypes.put(getSource(), targetType);
				outputDeclsAndTargetHostTypes.put(targetType, targetType);
				/* check for SPL errors */
				addSplErrors(featureID(), declsAndTargetHostTypes, "(by an implicit cast) the type",
						false, hostType(), false, FIRST_ROUND, outputDeclsAndTargetHostTypes, false, sourceType, sourceType);
			}
		}
	}
	
	/* handle up- and downcasts */
	public void CastExpr.splTypeCheck() {
		/* from java.ast: CastExpr : Expr ::= TypeAccess:Access Expr; */
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
  	Access ac = getTypeAccess();
  	if (ac instanceof TypeAccess) {
  		TypeAccess ta = (TypeAccess) ac;		  		
  		if (getExpr().type().isInTypeHierarchy(ta.decl())) {
  			/* Expr side of CastExpr is in type hierarchy beneath 
  			 * the TypeAccess side => upcast */
  			declsAndTargetHostTypes.put(ta.decl(), ta.decl().hostType());
  			/* check for SPL errors */
  			addSplErrors(featureID(), declsAndTargetHostTypes, "by a cast the type", false, hostType(), 
  					false, FIRST_ROUND, declsAndTargetHostTypes, false, getExpr().type(), getExpr().type());
  		} else if (ta.decl().isInTypeHierarchy(getExpr().type())) {
  			/* TypeAccess side of CastExpr is in type hierarchy beneath 
  			 * the Expr side => downcast */
  			declsAndTargetHostTypes.put(getExpr().type(), getExpr().type().hostType());
  			/* check for SPL errors */
  			addSplErrors(featureID(), declsAndTargetHostTypes, "by a cast the type", false, hostType(), 
  					false, FIRST_ROUND, declsAndTargetHostTypes, false, ta.decl(), ta.decl());
  		}
  	}
  }
	
	/* */
	public void SuperConstructorAccess.splTypeCheck() {
		HashMap<ASTNode, TypeDecl> declsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
		for (Iterator iter = decls().iterator(); iter.hasNext();) {
			ConstructorDecl cd = (ConstructorDecl) iter.next();
			/* don't consider trivial super constructor accesses 
			 * (i.e. class has no super class but Object) */
			if (!(cd.hostType().name().equals("Object"))) {
				declsAndTargetHostTypes.put(cd, cd.hostType());
			}
		}
		/* if there are non-trivial super constructor accesses */
		if (!(declsAndTargetHostTypes.keySet().isEmpty())) {
			/* check for SPL errors */
			addSplErrors(featureID(), declsAndTargetHostTypes, "the super constructor", false, hostType(), 
					false, FIRST_ROUND, declsAndTargetHostTypes, false, hostType(), hostType());
			/* check, if types of arguments fit the constructor declaration 
			 * (i.e. check, if the information that the type of an argument is 
			 * a subtype of the expected parameter is always available due to 
			 * the feature model) */
			for (ASTNode decl : declsAndTargetHostTypes.keySet()) {
				if (decl instanceof ConstructorDecl) {
					ConstructorDecl cd = (ConstructorDecl) decl;
					for (int i = 0; i < getNumArg(); i++) {
						/* different type of argument and parameter */
						if (!((getArg(i).type()).equals((cd.getParameter(i).type())))) {
							HashMap<ASTNode, TypeDecl> typeDeclsAndTargetHostTypes = new HashMap<ASTNode, TypeDecl>();
							typeDeclsAndTargetHostTypes.put(cd.getParameter(i).type(), cd.getParameter(i).type().hostType());
							/* check for SPL errors */
			  			addSplErrors(featureID(), typeDeclsAndTargetHostTypes, "by an implicit cast from argument type to parameter type", false, hostType(), 
			  					false, FIRST_ROUND, typeDeclsAndTargetHostTypes, false, getArg(i).type(), getArg(i).type());
						}
					}
				}
			}
		}
	}
	
}