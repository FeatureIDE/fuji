/* Extended Type Check
 * 2012-04-14
 * 
 * IPORTANT: 
 * add jar de.ovgu.featureide.fm.core... (FM-Test 03)
 * to Fuji's build-path
 * 
 * 
 * TODO: update comment
 * 
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.nameCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * (MethodAccess.nameCheck())
 * - checks, if one feature tries to access a method of a second feature
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * 
 * further:
 * - types
 * - classes
 * - interfaces
 * (optional and mutual exclusion)  
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

aspect ExtendedTypeCheck {

	/* copied from ErrorCheck.jrag and modified: added "spl" or "Spl" */

	public void ASTNode.collectSplErrors() {
		//		    nameCheck();
		//		    typeCheck();
		//		    accessControl();
		//		    exceptionHandling();
		//		    checkUnreachableStmt();
		//		    definiteAssignment();
		//		    checkModifiers();
		splTypeCheck();
		for(int i = 0; i < getNumChild(); i++) {
			getChild(i).collectSplErrors();
		}
	}

	public void Program.splErrorCheck(Collection collection) {
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
			}
		}
	}
	public void Program.splErrorCheck(Collection collection, Collection warn) {
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
				warn.addAll(cu.warnings);
			}
		}
	}

	public void CompilationUnit.splErrorCheck(Collection collection) {
		collectSplErrors();
		collection.addAll(errors);
	}
	public void CompilationUnit.splErrorCheck(Collection err, Collection warn) {
		collectSplErrors();
		err.addAll(errors);
		warn.addAll(warnings);
	}

	public boolean Program.splErrorCheck() {
		Collection collection = new LinkedList();
		splErrorCheck(collection);
		if(collection.isEmpty())
			return false;
		System.out.println("SPL Errors:");
		for(Iterator iter = collection.iterator(); iter.hasNext(); ) {
			String s = (String)iter.next();
			System.out.println(s);
		}
		return true;
	}

	/* /copy_&_modify */
	

	public void ASTNode.addSplErrors(int fromFeatureID,
			int toFeatureID, String targetStructure, String decl) {

		/* TODO: file name from outside */
		FeatureModel model = getFeatureModel("model.m");

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());

		/* beide Features vorhanden? */
		if(fromFeatureID != -1 && toFeatureID != -1) {

			/* Wird auf ein anderes Feature zugegriffen? */
			if (!(fromFeatureID == toFeatureID)) {
				/*
				 * Auf Reihenfolge Features aus dem FM zu
				 * Feature(-ID)s aus dem AST achten!
				 */				
				Feature fromFeature = model.getFeature(listFeatures
						.get(fromFeatureID).getName());

				Feature toFeature = model.getFeature(listFeatures
						.get(toFeatureID).getName());					 

				/* mit SAT-Solver testen, ob dieser Umstand 
				 * (Zugriff auf Feld in optionalem Feature)
				 * als zusŠtzliches Constraint im FM berŸcksichtigt 
				 * wurde: fromFeature implies toFeature 
				 * falls ja: okay
				 * falls nein: Fehlermeldung
				 *  (oder HinzufŸgen des Constraints zum FM)
				 */

				FeatureDependencies dep = new FeatureDependencies(model);	 

				String declFirstLine = 
						( decl.indexOf("\n") == -1 ? 
								decl : decl.substring(0, decl.indexOf("\n")) + " ...");

				if(never(dep, fromFeature, toFeature)) {
					/*
					 * Zugriff auf ein Feld/eine Methode/einen Typen in einem Feature
					 * gefunden, das in gegenseitigem Ausschluss steht
					 * -> Fehlermeldung
					 */					
					error("never-Beziehung:" 
							+ "\n    Feature " + fromFeature.getName()
							+ " greift auf " + targetStructure 
							+ "\n" + declFirstLine
							+ "\n    des Features "
							+ toFeature.getName() + " zu.\n    "
							+ fromFeature.getName() + " und "
							+ toFeature.getName()
							+ " kšnnen aber "
							+ "nicht beide gleichzeitig in einer validen "
							+ "Auswahl vorkommen.\n");
				}

				if(maybe(dep, fromFeature, toFeature)) {
					/*
					 * Zugriff auf ein Feld/eine Methode/einen Typen 
					 * in einem optionalen Feature
					 * gefunden -> Fehlermeldung
					 */					
					error("maybe-Beziehung:"
							+ "\n    Feature " + fromFeature.getName()
							+ " greift auf " + targetStructure
							+ "\n" + declFirstLine
							+ "\n    des Features "
							+ toFeature.getName() + " zu.\n"
							+ "Das Ziel-Feature ist aber nicht in jeder "
							+ "mšglichen validen Auswahl vorhanden.\n");
				}
			}
		}		
	}

	public void ASTNode.addSplErrors(int fromFeatureID,
			ArrayList<Integer> toFeatureIDs, String targetStructure, 
			HashMap<Integer, ASTNode> mapDecls) {

		/* TODO: file name from outside */
		FeatureModel model = getFeatureModel("model.m");

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());

		Feature fromFeature = model.getFeature(listFeatures
				.get(fromFeatureID).getName());

		ArrayList<Set<Feature>> listToFeatures = new ArrayList<Set<Feature>>();

		for (int toFeatureID : toFeatureIDs) {
			Feature toFeature = model.getFeature(listFeatures.get(toFeatureID).getName());
			HashSet<Feature> toFeatureSet = new HashSet<Feature>();
			toFeatureSet.add(toFeature);
			listToFeatures.add(toFeatureSet);
		}

		try {
			if (!(model.areMutualExclusive(null, listToFeatures))) {
				StringBuilder sb = new StringBuilder();
				sb.append(toFeatureIDs.size());
				sb.append(" mšgliche Ziele:\n");
				sb.append(fromFeature.getName());
				sb.append(" zielt auf ");
				sb.append(targetStructure);
				sb.append(" folgender Features:\n");
				for (int toFeatureID : toFeatureIDs) {
					sb.append(model.getFeature(listFeatures.get(toFeatureID).getName()).getName());
					sb.append(":\t");
					sb.append(mapDecls.get(toFeatureID));
					sb.append("\n");
				}
				sb.append("\n");
				error(sb.toString());
			}
		} catch (TimeoutException e) {
			e.printStackTrace();
		}
	}

	public void ASTNode.splTypeCheck() {

	}

	public void VarAccess.splTypeCheck() {
		HashMap<Integer, ASTNode> mapDecls = new HashMap<Integer, ASTNode>();

		/* Ist der Variablenzugriff ein Feldzugriff? */
		if (isFieldAccess()) {			
			int fromFeatureID = featureID();
			SimpleSet decls = decls();
			if (decls.size() == 1) {
				BodyDecl var = (BodyDecl) decl();
				int toFeatureID = var.featureID();
				addSplErrors(fromFeatureID, toFeatureID, "das Feld", 
						var.toString());
			} else {
				ArrayList<Integer> toFeatureIDs = new ArrayList<Integer>();
				for(Iterator iter = decls.iterator(); iter.hasNext(); ){
					BodyDecl var = (BodyDecl) iter.next();
					toFeatureIDs.add(var.featureID());
					mapDecls.put(var.featureID(), var);
				}
				addSplErrors(fromFeatureID, toFeatureIDs, "das Feld", 
						mapDecls);
			}
		}    
	}

	public void MethodAccess.splTypeCheck() {
		HashMap<Integer, ASTNode> mapDecls = new HashMap<Integer, ASTNode>();

		int fromFeatureID = featureID();
		SimpleSet decls = decls();
		if (decls.size() == 1) {
			MethodDecl var = (MethodDecl) decl();
			int toFeatureID = var.featureID();
			addSplErrors(fromFeatureID, toFeatureID, "die Methode", 
					var.toString());
		} else {
			ArrayList<Integer> toFeatureIDs = new ArrayList<Integer>();
			for(Iterator iter = decls.iterator(); iter.hasNext(); ){
				MethodDecl var = (MethodDecl) iter.next();
				toFeatureIDs.add(var.featureID());
				mapDecls.put(var.featureID(), var);
			}
			addSplErrors(fromFeatureID, toFeatureIDs, "die Methode", 
					mapDecls);
		}
	}

	public void TypeAccess.splTypeCheck() {
		HashMap<Integer, ASTNode> mapDecls = new HashMap<Integer, ASTNode>();
		boolean defaultType = false;

		int fromFeatureID = featureID();
		SimpleSet decls = decls();
		//		if (decls.size() == 1) {
		//			TypeDecl var = (TypeDecl) decl();
		//			int toFeatureID = var.featureID();
		////			System.out.print("Typ: ");
		////			TypeDecl varDecl = (TypeDecl) decls.iterator().next();
		////			System.out.print(varDecl.featureID() + " " + varDecl.toString());
		////			System.out.print("\t" + toFeatureID + " " + var.toString() + "\n");
		//			addSplErrors(fromFeatureID, toFeatureID, "den Typ", 
		//					var.toString());
		//		} else {
		//		System.out.print("Types: ");
		ArrayList<Integer> toFeatureIDs = new ArrayList<Integer>();
		for(Iterator iter = decls.iterator(); iter.hasNext(); ){
			TypeDecl var = (TypeDecl) iter.next();
			toFeatureIDs.add(var.featureID());
			//			    System.out.print(var.featureID() + " ");
			defaultType = (var.featureID() == -1);
			mapDecls.put(var.featureID(), var);
		}
		//		    System.out.println();
		if (!(defaultType)) {
			addSplErrors(fromFeatureID, toFeatureIDs, "den Typ", 
					mapDecls);
		}
		//		}
	}

	public FeatureModel ASTNode.getFeatureModel(String fmFileName) {
		/* read in Feature-Model */
		FeatureModel model = new FeatureModel();
		File guidsl_file = new File(fmFileName);

		GuidslReader reader = new GuidslReader(model);
		try {
			reader.readFromFile(guidsl_file);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (UnsupportedModelException e) {
			e.printStackTrace();
		}
		return model;
	}

	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}
}