/* Extended Type Check
 * 2012-04-14
 * 
 * IPORTANT: 
 * add jar de.ovgu.featureide.fm.core... (FM-Test 01) and
 * add jar org.eclipse.core.resources... (FM-Test 02)
 * add jar org.sat4j.core
 * to Fuji's build-path
 * 
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.nameCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * 
 * TODO:
 * - implement always, sometimes, never  
 *   
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

import org.prop4j.And;
import org.prop4j.Not;

aspect ExtendedTypeCheck {
	
	refine NameCheck public void VarAccess.nameCheck() {
		
		/* copy & paste */	
	    if(decls().isEmpty() && (!isQualified() || !qualifier().type().isUnknown() || qualifier().isPackageAccess()))
	      error("no field named " + name());
	    if(decls().size() > 1) {
	      StringBuffer s = new StringBuffer();
	      s.append("several fields named " + name());
	      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
	        Variable v = (Variable)iter.next();
	        s.append("\n    " + v.type().typeName() + "." + v.name() + " declared in " + v.hostType().typeName());
	      }
	      error(s.toString());
	    }
	      
	    // 8.8.5.1
	    if(inExplicitConstructorInvocation() && !isQualified() && decl().isInstanceVariable() && hostType() == decl().hostType())
	      error("instance variable " + name() + " may not be accessed in an explicit constructor invocation");

	    Variable v = decl();
	    if(!v.isFinal() && !v.isClassVariable() && !v.isInstanceVariable() && v.hostType() != hostType())
	      error("A parameter/variable used but not declared in an inner class must be declared final");

	    // 8.3.2.3
	    if((decl().isInstanceVariable() || decl().isClassVariable()) && !isQualified()) {
	      if(hostType() != null && !hostType().declaredBeforeUse(decl(), this)) {
	        if(inSameInitializer() && !simpleAssignment() && inDeclaringClass()) {
	          BodyDecl b = closestBodyDecl(hostType());
	          error("variable " + decl().name() + " is used in " + b + " before it is declared");
	        }
	      }
	    }	    
	    /* /copy & paste */
	    
	    /* new */	    
	    /* TODO: file name from outside
	     * read in Feature-Model */
	    FeatureModel model = new FeatureModel();
	    File guidsl_file = new File("neededButOptionalField.m");

		GuidslReader reader = new GuidslReader(model);
		try {
			reader.readFromFile(guidsl_file);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (UnsupportedModelException e) {
			e.printStackTrace();
		}
		
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());
	    
			/* Ist der Variablenzugriff ein Feldzugriff? */
			if (isFieldAccess()) {
				int fromFeatureID = featureID();
				int toFeatureID = decl().hostType().featureID();
				
				/* Wird auf ein anderes Feature zugegriffen? */
				if (!(fromFeatureID == toFeatureID)) {
					/*
					 * Auf Reihenfolge Features aus dem FM zu
					 * Feature(-ID)s aus dem AST achten!
					 */				
					 Feature fromFeature = model.getFeature(listFeatures
					     .get(fromFeatureID).getName());
					 
					 Feature toFeature = model.getFeature(listFeatures
					     .get(toFeatureID).getName());					 

					/* TODO: kann weggelassen werden, loeschen */
					/* Ist Ziel-Feature optional? */			
					//if (!(toFeature.isMandatory())) {
										
						/* mit SAT-Solver testen, ob dieser Umstand 
						 * (Zugriff auf Feld in optionalem Feature)
						 * als zusätzliches Constraint im FM berücksichtigt 
						 * wurde: fromFeature implies toFeature 
						 * falls ja: okay
						 * falls nein: Fehlermeldung
						 *  (oder Hinzufügen des Constraints zum FM)
						 */
						
						Set<Feature> toFeatures = new HashSet<Feature>();
						toFeatures.add(toFeature);
						
						Set<Feature> fromFeatures = new HashSet<Feature>();
						fromFeatures.add(fromFeature);
						
						try {
							if(!(always(model, fromFeatures, toFeatures))) {
								/*
						         * Zugriff auf ein Feld in einem optionalen Feature
						         * gefunden -> Fehlermeldung
						         */					
						        error("Feature " + fromFeature.getName()
								    + " greift auf das Feld\n" + decl()
								    + "\ndes optionalen Features "
								    + toFeature.getName() + " zu.");
							}
						} catch (TimeoutException e) {
							e.printStackTrace();
						}
					//}				
				}
			}	
	    /* /new */
	    
	  }
	
	  /* beide immer (wirklich: A und B ?) */
	  protected boolean ASTNode.always(FeatureModel model, 
			                           Set<Feature> fromFeatures, 
			                           Set<Feature> toFeatures) 
			                        		   throws TimeoutException {
		  
		  return model.checkImplies(fromFeatures, toFeatures); 
		  // return model.checkCondition(new And(fromFeatures, toFeatures));
	  }
	  
//	  /* gegenseitiger Ausschluss */
//	  /* TODO: was ist hier mit context gemeint? ->
//	   * model.areMutualExclusive(context, featureslist); */
//	  protected boolean ASTNode.never(FeatureModel model,
//			                          Set<Feature> fromFeatures,
//			                          Set<Feature> toFeatures) {
//		  
//		  List<Set<Feature>> list = new List<Set<Feature>>();
//		  list.add(fromFeatures);
//		  list.add(toFeatures);
//		  
//		  // return model.checkCondition(new And(fromFeatures, new Not(toFeatures)));
//		  return model.areMutualExclusive(fromFeatures, list);
//	  }
//	  
//	  /* def. */
//	  protected boolean ASTNode.sometimes(FeatureModel model,
//			                              Set<Feature> fromFeatures,
//			                              Set<Feature> toFeatures) 
//			                                  throws TimeoutException {
//		  return !(always(model, fromFeatures, toFeatures)) &&
//				  !(never(model, fromFeatures, toFeatures));
//	  }
}