/* Extended Type Check
 * 2012-04-14
 * 
 * IPORTANT: 
 * add jar de.ovgu.featureide.fm.core... (FM-Test 01) and
 * add jar org.eclipse.core.resources... (FM-Test 02)
 * add jar org.sat4j.core
 * to Fuji's build-path
 * 
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.nameCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error
 *   
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

aspect ExtendedTypeCheck {
	
	refine NameCheck public void VarAccess.nameCheck() {
		
		/* copy & paste */	
	    if(decls().isEmpty() && (!isQualified() || !qualifier().type().isUnknown() || qualifier().isPackageAccess()))
	      error("no field named " + name());
	    if(decls().size() > 1) {
	      StringBuffer s = new StringBuffer();
	      s.append("several fields named " + name());
	      for(Iterator iter = decls().iterator(); iter.hasNext(); ) {
	        Variable v = (Variable)iter.next();
	        s.append("\n    " + v.type().typeName() + "." + v.name() + " declared in " + v.hostType().typeName());
	      }
	      error(s.toString());
	    }
	      
	    // 8.8.5.1
	    if(inExplicitConstructorInvocation() && !isQualified() && decl().isInstanceVariable() && hostType() == decl().hostType())
	      error("instance variable " + name() + " may not be accessed in an explicit constructor invocation");

	    Variable v = decl();
	    if(!v.isFinal() && !v.isClassVariable() && !v.isInstanceVariable() && v.hostType() != hostType())
	      error("A parameter/variable used but not declared in an inner class must be declared final");

	    // 8.3.2.3
	    if((decl().isInstanceVariable() || decl().isClassVariable()) && !isQualified()) {
	      if(hostType() != null && !hostType().declaredBeforeUse(decl(), this)) {
	        if(inSameInitializer() && !simpleAssignment() && inDeclaringClass()) {
	          BodyDecl b = closestBodyDecl(hostType());
	          error("variable " + decl().name() + " is used in " + b + " before it is declared");
	        }
	      }
	    }	    
	    /* /copy & paste */
	    
	    /* new */	    
	    /* TODO: file name from outside
	     * read in Feature-Model */
	    FeatureModel model = new FeatureModel();
	    File guidsl_file = new File("neededButOptionalField.m");

		GuidslReader reader = new GuidslReader(model);
		try {
			reader.readFromFile(guidsl_file);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (UnsupportedModelException e) {
			e.printStackTrace();
		}
		
		/* TODO: get all features, ACHTUNG: Reihenfolge */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch alle benoetigten Features in der 
		 * richtigen Reihenfolge eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());
	    
			/* Ist der Variablenzugriff ein Feldzugriff? */
			if (isFieldAccess()) {
				int fromFeatureID = featureID();
				int toFeatureID = decl().hostType().featureID();
				
				/* Wird auf ein anderes Feature zugegriffen? */
				if (!(fromFeatureID == toFeatureID)) {
					/*
					 * Auf Reihenfolge Features aus dem FM zu
					 * Feature(-ID)s aus dem AST achten!
					 */				
					 Feature fromFeature = model.getFeature(listFeatures
					     .get(fromFeatureID).getName());
					 
					 Feature toFeature = model.getFeature(listFeatures
					     .get(toFeatureID).getName());					 

					/* Ist Ziel-Feature optional? */			
					if (!(toFeature.isMandatory())) {
										
						/* mit SAT-Solver testen, ob dieser Umstand 
						 * (Zugriff auf Feld in optionalem Feature)
						 * als zusätzliches Constraint im FM berücksichtigt 
						 * wurde: fromFeature implies toFeature 
						 * falls ja: okay
						 * falls nein: Fehlermeldung
						 *  (oder Hinzufügen des Constraints zum FM)
						 */
						
						Set<Feature> toFeatures = new HashSet<Feature>();
						toFeatures.add(toFeature);
						
						Set<Feature> fromFeatures = new HashSet<Feature>();
						fromFeatures.add(fromFeature);
						
						try {
							if(!(model.checkImplies(fromFeatures, toFeatures))) {
						
								/*
						         * Zugriff auf ein Feld in einem optionalen Feature
						         * gefunden -> Fehlermeldung
						         */					
						        error("Feature " + fromFeature.getName()
								    + " greift auf das Feld\n" + decl()
								    + "\ndes optionalen Features "
								    + toFeature.getName() + " zu.");
							}
						} catch (TimeoutException e) {
							e.printStackTrace();
						}
					}				
				}
			}	
	    /* /new */
	    
	  }
}