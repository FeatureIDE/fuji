/* Extended Type Check
 * 2012-04-14
 * 
 * IPORTANT: 
 * add jar de.ovgu.featureide.fm.core... (FM-Test 03)
 * to Fuji's build-path
 * 
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.nameCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * (MethodAccess.nameCheck())
 * - checks, if one feature tries to access a method of a second feature
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * 
 * further:
 * - types
 * - classes
 * - interfaces
 * (optional and mutual exclusion)  
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

aspect ExtendedTypeCheck {
	
	public void ASTNode.optionalAndMutualExclusiveErrors(int fromFeatureID,
			int toFeatureID, String targetStructure, String decl) {
		
		/* TODO: file name from outside */
		FeatureModel model = getFeatureModel("model.m");

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());
		
		/* beide Features vorhanden? */
		if(fromFeatureID != -1 && toFeatureID != -1) {

			/* Wird auf ein anderes Feature zugegriffen? */
			if (!(fromFeatureID == toFeatureID)) {
				/*
				 * Auf Reihenfolge Features aus dem FM zu
				 * Feature(-ID)s aus dem AST achten!
				 */				
				Feature fromFeature = model.getFeature(listFeatures
						.get(fromFeatureID).getName());

				Feature toFeature = model.getFeature(listFeatures
						.get(toFeatureID).getName());					 

				/* mit SAT-Solver testen, ob dieser Umstand 
				 * (Zugriff auf Feld in optionalem Feature)
				 * als zusŠtzliches Constraint im FM berŸcksichtigt 
				 * wurde: fromFeature implies toFeature 
				 * falls ja: okay
				 * falls nein: Fehlermeldung
				 *  (oder HinzufŸgen des Constraints zum FM)
				 */

				FeatureDependencies dep = new FeatureDependencies(model);	 

				if(never(dep, fromFeature, toFeature)) {
					/*
					 * Zugriff auf ein Feld/eine Methode in einem Feature
					 * gefunden, das in gegenseitigem Ausschluss steht
					 * -> Fehlermeldung
					 */					
					error("gegenseitiger Ausschluss:" 
							+ "\n    Feature " + fromFeature.getName()
							+ " greift auf " + targetStructure 
							+ "\n      " + decl
							+ "\n    des Features "
							+ toFeature.getName() + " zu.\n    "
							+ fromFeature.getName() + " und "
							+ toFeature.getName()
							+ " schlie§en sich aber "
							+ "gegenseitig aus.\n");
				}

				if(maybe(dep, fromFeature, toFeature)) {
					/*
					 * Zugriff auf ein Feld/eine Methode 
					 * in einem optionalen Feature
					 * gefunden -> Fehlermeldung
					 */					
					error("Zugriff auf Feld in einem optionalen Feature:"
							+ "\n    Feature " + fromFeature.getName()
							+ " greift auf " + targetStructure
							+ "\n      " + decl
							+ "\n    des optionalen Features "
							+ toFeature.getName() + " zu.\n");
				}
			}
		}		
	}

	public void VarAccess.typeCheck() {
		/* Ist der Variablenzugriff ein Feldzugriff? */
		if (isFieldAccess()) {			
			int fromFeatureID = featureID();
			int toFeatureID = decl().hostType().featureID();
			optionalAndMutualExclusiveErrors(fromFeatureID, toFeatureID, 
					"das Feld", decl().toString());
		}	  
	}
	
	refine MethodSignature15 public void MethodAccess.typeCheck() {
		refined();
		int fromFeatureID = featureID();
		int toFeatureID = decl().hostType().featureID();
		optionalAndMutualExclusiveErrors(fromFeatureID, toFeatureID,
				"die Methode", decl().toString());	
	}
	
	public FeatureModel ASTNode.getFeatureModel(String fmFileName) {
		/* read in Feature-Model */
		FeatureModel model = new FeatureModel();
		File guidsl_file = new File(fmFileName);

		GuidslReader reader = new GuidslReader(model);
		try {
			reader.readFromFile(guidsl_file);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (UnsupportedModelException e) {
			e.printStackTrace();
		}
		return model;
	}

	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}
}