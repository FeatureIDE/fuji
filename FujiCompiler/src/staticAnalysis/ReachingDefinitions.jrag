aspect ReachingDefinitions {
        syn boolean CFGNode.isDef() = false;
        eq Access.isDef() = isDest();
        eq MethodAccess.isDef() = true;
        eq ConstructorAccess.isDef() = true;
        eq ClassInstanceExpr.isDef() = true;

        // reaching definitions
        public SmallSet<CFGNode> Access.reachingDefinitions() {
        		//System.out.println("BAAAHH" + ((VarAccess)this).decl());
                Location l = getLocation();
                //Need to check if the Access is the left part of the AbstractDot?
                if(!isSource() || l == null || (getParent() instanceof AbstractDot && !((AbstractDot)getParent()).isSource()))
                        return SmallSet.<CFGNode>empty();
                // we don't want the node to be its own reaching definition
                SmallSet<CFGNode> res = SmallSet.<CFGNode>empty();
                //System.out.println("\n__ ACCESS __\n");
            	//System.out.println("Calculating RD for: " + this + ":" + lineNumber() + ". Location: " + l);
                //System.out.println();
                /*for(CFGNode p : pred())
                	System.out.println(p.toString() + " :: " + ((ASTNode)p).lineNumber() + " :: " + p.getClass());
                System.out.println();*/
                for(CFGNode p : pred()) {
                	//SmallSet<CFGNode> rd = p.reachingDefinitionsFor(l);
                	//if (rd.size()!=0) {
                		//res = SmallSet.<CFGNode>singleton((FieldDeclaration)((VarAccess)this).decl());
                	//}// else {
                		res = res.union(p.reachingDefinitionsFor(l));
                //	}
                	//System.out.println("SIZE: " + pred().size());
                	//System.out.println("PRED: " + p + "\t LINE: " + ((ASTNode)p).lineNumber());
                }
                return res;
        }

        public SmallSet<CFGNode> VarAccess.reachingDefinitions() {
            // BUG: no isField() in Variable (returned by decl())
            //if(decl().isField()) {
        		
        		//System.out.println("VARACCESS:" + this.toString() +", Location:"+ this.lineNumber());
        		//FieldDeclaration fd = null;
        		//SmallSet<CFGNode> res = super.reachingDefinitions();
                if(isFieldAccess()) {
                	 	//System.out.println("FIELD ACCESS, RD.size:" /*+ res.size()*/);
                		FieldDeclaration fd = (FieldDeclaration)decl();
                    	//System.out.println("Decl:" + fd.toString() +" INIT: " + fd.hasInit());
                        if(fd.isConstant() && fd.hasInit()) //|| (res.size()==0))
                                return SmallSet.<CFGNode>singleton(fd);
                }
//               SmallSet<CFGNode> res = super.reachingDefinitions(); //res;
//               if (res.contains(null)) {
//            	   res.compl(null);
//            	   if (fd != null)
//            		   res.add(fd);
//               }
            	   
               return super.reachingDefinitions();
        }

        // reached uses
        public SmallSet<Access> Access.reachedUses() {
                Location l = getLocation();
                if(!isDest() || l == null)
                        return SmallSet.<Access>empty();
                // we don't want the node to be its own reached use
                SmallSet<Access> res = SmallSet.<Access>empty();
                for(CFGNode p : succ())
                        res = res.union(p.reachedUsesFor(l));
                return res;
        }

        // BUG: this attribute is refereneced in the next one, but was never
        // defined.
        public SmallSet<VarAccess> Variable.allUses() {
            return collAllUses();
        }
        coll SmallSet<VarAccess> Variable.collAllUses()
            [SmallSet.<VarAccess>empty()] with add root CompilationUnit;
        VarAccess contributes this to Variable.collAllUses() for decl();

        public SmallSet<Access> VarAccess.reachedUses() {
                if(isDest() && decl().isLocalVariable() && decl().isFinal()) {
                        SmallSet<Access> res = SmallSet.<Access>empty();
                        for(VarAccess u : decl().allUses())
                                if(u.isSource())
                                        res = res.union(u);
                        return res;
                } else {
                        return super.reachedUses();
                }
        }

        syn lazy SmallSet<CFGNode> CFGNode.reachingDefinitionsFor(Location l)
                circular [SmallSet.<CFGNode>empty()] {
                SmallSet<CFGNode> res = SmallSet.<CFGNode>empty();
                if ((isReachingDefinitionFor(l)) || (this instanceof ASTNode && (ASTNode)this instanceof CFGEntry)) {
                		//if (this.getClass() instanceof Access)
                		//System.out.println( this + ": "+ this.lineNumber() +" - " + this.getClass() + "; is blocking " + l + ":" + l.getClass() + "? " + isBlockingDefinitionFor(l));
                        res = SmallSet.singleton((CFGNode)this);
                        //if(isBlockingDefinitionFor(l))
                        return res;
                }
            	//System.out.println("Preds of " + this.toString() + ", Number of Preds: " + pred().size() );
              /*  System.out.println();
                if (pred().size() == 0)
                	System.out.println("No Pred  :: Pred of " + this.toString());
                else {
                	for(CFGNode p : pred())   
                		System.out.println(p.toString() + " :: " + ((ASTNode)p).lineNumber() + " :: " + p.getClass() + ":: Pred of " + this.toString());		
                }
                System.out.println();*/
                for(CFGNode p : pred())  {             	
                		//System.out.println("SIZE: " + pred().size());
                		//System.out.println("PRED: " + p + "\t LINE: " + ((ASTNode)p).lineNumber());
                        res = res.union(p.reachingDefinitionsFor(l));
                /*if (res.size() < pred().size())
                	System.out.println("POSSIBLY NOT INITIALIZED");*/
                }
                return res;
        }

        syn lazy SmallSet<Access> CFGNode.reachedUsesFor(Location l) circular [SmallSet.<CFGNode>empty()] {
                SmallSet<Access> res = SmallSet.<Access>empty();
                if(isBlockingDefinitionFor(l))
                        return res;
                for(CFGNode s : succ())
                        res = res.union(s.reachedUsesFor(l));
                return res;
        }

        eq Access.reachedUsesFor(Location l) {
                SmallSet<Access> res = SmallSet.<Access>empty();
                if(isReachedUseFor(l))
                        res = SmallSet.singleton((Access)this);
                if(isBlockingDefinitionFor(l))
                        return res;
                for(CFGNode s : succ())
                        res = res.union(s.reachedUsesFor(l));
                return res;
        }

        syn boolean Stmt.isReachingDefinitionFor(Location l) = false;
        syn boolean Stmt.isBlockingDefinitionFor(Location l) = false;
        syn boolean Stmt.isReachedUseFor(Location l) = false;

        syn boolean Expr.isReachingDefinitionFor(Location l) = false;
        syn boolean Expr.isBlockingDefinitionFor(Location l) = false;
        syn boolean Expr.isReachedUseFor(Location l) = false;

        syn boolean ParameterDeclaration.isReachingDefinitionFor(Location l) = mayAlias(l);
        syn boolean ParameterDeclaration.isBlockingDefinitionFor(Location l) = mustAlias(l);
        syn boolean ParameterDeclaration.isReachedUseFor(Location l) = false;

        eq VariableDeclaration.isReachingDefinitionFor(Location l) = mayAlias(l) && isInitialised(); // <- why? even uninitialized it's a reaching definition
        eq VariableDeclaration.isBlockingDefinitionFor(Location l) = mustAlias(l);
        eq VariableDeclaration.isReachedUseFor(Location l) = false;

        eq Access.isReachingDefinitionFor(Location l) = isDest() && l.mayAlias(getLocation());
        eq Access.isBlockingDefinitionFor(Location l) = isDest() && l.mustAlias(getLocation()); // <- mustAlias() of FieldDecl requires field to be static, why? 
        eq Access.isReachedUseFor(Location l) = isSource() && l.mayAlias(getLocation());

        eq MethodAccess.isReachingDefinitionFor(Location l) = l.mayAlias(getLocation());
        eq MethodAccess.isReachedUseFor(Location l) = l.mayAlias(getLocation());

        // take care of local variable references from within local/anonymous
        // classes
        // BUG : no EtryStmt node
        // eq EntryStmt.reachingDefinitionsFor(Location l) {
        //      SmallSet<CFGNode> res = getParent() instanceof Callable && l.isHeapLocation() ? SmallSet.<CFGNode>singleton(this) : SmallSet.<CFGNode>empty();
        //      if(hostType().isLocalClass()) {
        //              return res.union(((LocalClassDeclStmt)hostType().getParent()).reachingDefinitionsFor(l));
        //      } else if(hostType().isAnonymous()) {
        //              return res.union(((ClassInstanceExpr)hostType().getParent().getParent()).reachingDefinitionsFor(l));
        //      }
        //      //return super.reachingDefinitionsFor(l);
        //      for(CFGNode p : pred())
        //              res = res.union(p.reachingDefinitionsFor(l));
        //      return res;
        // }

        // add field declaration as reaching definition
        // BUG : no ExitStmt node
        // eq ExitStmt.reachingDefinitionsFor(Location l) {
        //         SmallSet<CFGNode> res = SmallSet.<CFGNode>empty();
        //         if(getParent() instanceof FieldDeclaration) {
        //                 FieldDeclaration fd = (FieldDeclaration)getParent();
        //                 if(fd.isReachingDefinitionFor(l)) {
        //                         res = SmallSet.singleton((CFGNode)fd);
        //                         if(fd.isBlockingDefinitionFor(l))
        //                                 return res;
        //                 }
        //         }
        //         for(CFGNode p : pred())
        //                 res = res.union(p.reachingDefinitionsFor(l));
        //         return res;
        // }

        syn boolean FieldDeclaration.isReachingDefinitionFor(Location l) = this == l;
        syn boolean FieldDeclaration.isBlockingDefinitionFor(Location l) = false;
        syn boolean FieldDeclaration.isReachedUseFor(Location l) = false;

        syn boolean VariableDeclaration.isInitialised() =
                hasInit() || getParent() instanceof EnhancedForStmt;

        // r.hasReachingDefinitionBefore(n): is there some reaching definition w for r such that
        // n is encountered along the path from r back to w?
        // BUG: not used
        // public boolean VarAccess.hasReachingDefinitionBefore(CFGNode n) {
        //         Location l = getLocation();
        //         if(!isSource() || l == null)
        //                 return false;
        //         // we don't want the node to be its own reaching definition
        //         for(CFGNode pred : pred())
        //                 if(pred.hasReachingDefinitionBefore(l, n))
        //                         return true;
        //         return false;
        // }

        // bug: not used
        // syn boolean CFGNode.hasReachingDefinitionBefore(Location l, CFGNode n) circular [false] {
        //         if(this == n)
        //                 return !reachingDefinitionsFor(l).isEmpty();
        //         if(isBlockingDefinitionFor(l))
        //                 return false;
        //         for(CFGNode pred : pred())
        //                 if(pred.hasReachingDefinitionBefore(l, n))
        //                         return true;
        //         return false;
        // }

        // BUG : no EtryStmt node
        // eq EntryStmt.hasReachingDefinitionBefore(Location l, CFGNode n) {
        //         if(this == n)
        //                 return !reachingDefinitionsFor(l).isEmpty();
        //         if(isBlockingDefinitionFor(l) || getParent() instanceof Callable && l.isHeapLocation())
        //                 return false;
        //         if(hostType().isLocalClass()) {
        //                 return ((LocalClassDeclStmt)hostType().getParent()).hasReachingDefinitionBefore(l, n);
        //         } else if(hostType().isAnonymous()) {
        //                 return ((ClassInstanceExpr)hostType().getParent().getParent()).hasReachingDefinitionBefore(l, n);
        //         }
        //         for(CFGNode pred : pred())
        //                 if(pred.hasReachingDefinitionBefore(l, n))
        //                         return true;
        //         return false;
        // }

        // w.hasReachedUseAfter(n): is there some reached use r for w such that
        // n is encountered along the path from w to r?
        // BUG: not used
        // public boolean VarAccess.hasReachedUseAfter(CFGNode n) {
        //         Location l = getLocation();
        //         if(!isDest() || l == null)
        //                 return false;
        //         // we don't want the node to be its own reached use
        //         for(CFGNode succ : succ())
        //                 if(succ.hasReachedUseAfter(l, n))
        //                         return true;
        //         return false;
        // }

        // BUG: not used
        // syn boolean CFGNode.hasReachedUseAfter(Location l, CFGNode n) circular [false] {
        //         if(this == n)
        //                 return !reachedUsesFor(l).isEmpty();
        //         if(isBlockingDefinitionFor(l))
        //                 return false;
        //         for(CFGNode succ : succ())
        //                 if(succ.hasReachedUseAfter(l, n))
        //                         return true;
        //         return false;
        // }

        // checks if a subtree may reference a variable in any way
        // BUG: not used
        // public boolean ASTNode.mayRef(Variable v) {
        //         for(int i=0;i<getNumChild();++i) {
        //                 ASTNode child = getChild(i);
        //                 if(child != null && child.mayRef(v))
        //                         return true;
        //         }
        //         return false;
        // }

        // BUG: not used
        // public boolean VarAccess.mayRef(Variable v) {
        //         return decl() == v;
        // }

}